<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>cwmspy.cwms_ts API documentation</title>
<meta name="description" content="Facilities for working with time series" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cwmspy.cwms_ts</code></h1>
</header>
<section id="section-intro">
<p>Facilities for working with time series</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Facilities for working with time series
&#34;&#34;&#34;
import cx_Oracle
import datetime
import pandas as pd
from dateutil import tz
import pytz
import logging
from itertools import combinations
import numpy as np
import json
from json import JSONDecodeError

from .utils import log_decorator


LOGGER = logging.getLogger(__name__)
LD = log_decorator(LOGGER)


class CwmsTsMixin:
    @LD
    def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
        &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.

        Parameters
        ----------
        p_cwms_ts_id : str
            CWMS time series identifier.
        p_db_office_code : int
            The unique numeric code identifying the office
                               owning the time series

        Returns
        -------
        str
            the unique numeric code value for the specified
                time series if successful, False otherwise.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_code(&#34;Some.fully.qualified.ts.id&#34;)
            &#34;04319021&#34;

        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            ts_code = cur.callfunc(
                &#34;cwms_ts.get_ts_code&#34;,
                cx_Oracle.STRING,
                [p_cwms_ts_id, p_db_office_code],
            )
        except Exception as e:
            LOGGER.error(&#34;Error retrieving ts_code&#34;)
            cur.close()
            raise ValueError(e.__str__())
        LOGGER.info(f&#34;get_ts_code returned {ts_code}&#34;)
        cur.close()

        return ts_code

    @LD
    def get_ts_max_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The latest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_ts_max_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            datetime.datetime(2019, 8, 16, 7, 0)
        ```
        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            max_date = cur.callfunc(
                &#34;cwms_ts.get_ts_max_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except Exception as e:
            cur.close()
            LOGGER.error(&#34;Error retrieving get_ts_max_date&#34;)
            raise ValueError(e.__str__())
        LOGGER.info(f&#34;max_date returned {max_date}&#34;)
        cur.close()

        return max_date

    @LD
    def get_ts_min_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS

        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_min_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)

            datetime.datetime(1975, 2, 18, 8, 0)
        ```
        &#34;&#34;&#34;

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            min_date = cur.callfunc(
                &#34;cwms_ts.get_ts_min_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in retrieving get_ts_min_date&#34;)
            cur.close()
            raise ValueError(e.__str__())
        LOGGER.info(f&#34;get_ts_min_date returned {min_date}&#34;)
        cur.close()

        return min_date

    @LD
    def get_times_for_time_window(
        self, start_time, end_time, p_ts_id, p_time_zone, p_office_id=None
    ):

        p_start_time = pd.to_datetime(start_time).to_pydatetime()
        p_end_time = pd.to_datetime(end_time).to_pydatetime()
        # FUNCTION DATE TIME EXAMPLE
        cur = self.conn.cursor()
        date_table_type = self.conn.gettype(&#34;CWMS_20.DATE_TABLE_TYPE&#34;)
        try:
            date_table_time = cur.callfunc(
                &#34;cwms_ts.get_times_for_time_window&#34;,
                date_table_type,
                [p_start_time, p_end_time, p_ts_id, p_time_zone, p_office_id],
            )
            cur.close()
            return date_table_time

        except Exception as e:
            LOGGER.error(f&#34;Error retrieving ts_code {e}&#34;)
            cur.close()
            raise ValueError(e.__str__())
        return 0

    @LD
    def retrieve_ts_out(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=None,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.


        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; df = cwms.retrieve_ts_out(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                                start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
        &gt;&gt;&gt; df.head()
             date_time  value  quality_code     time_zone                          ts_id                                       alias              units
    2020-09-01 18:00:00    0.0             0       UTC  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW    mm
    2020-09-02 00:00:00    0.0             0       UTC  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW    mm

        ```
        &#34;&#34;&#34;
        p_start_time = pd.to_datetime(start_time).to_pydatetime()
        p_end_time = pd.to_datetime(end_time).to_pydatetime()

        if not version_date:
            version_date = &#34;1111/11/11&#34;
            p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        else:
            p_version_date = pd.to_datetime(version_date).to_pydatetime()

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        p_units_out = cur.var(cx_Oracle.STRING)
        p_cwms_ts_id_out = cur.var(cx_Oracle.STRING)
        try:

            cur.callproc(
                &#34;cwms_ts.retrieve_ts_out&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id_out,
                    p_units_out,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]
        output_len = len(output)
        LOGGER.info(f&#34;Found {output_len} records.&#34;)

        if return_df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )
            output[&#34;time_zone&#34;] = p_timezone
            output[&#34;ts_id&#34;] = p_cwms_ts_id_out.getvalue()
            output[&#34;alias&#34;] = p_cwms_ts_id
            output[&#34;units&#34;] = p_units_out.getvalue()

        return output

    @LD
    def retrieve_time_series(
        self,
        ts_ids,
        units=[&#34;EN&#34;],
        p_datums=None,
        p_start=None,
        p_end=None,
        p_timezone=&#34;UTC&#34;,
        p_office_id=None,
        as_json=False,
    ):
        &#34;&#34;&#34;Retreives time series in a number of formats for a combination 
        time window, timezone, formats, and vertical datums 

        Parameters
        ----------
        ts_ids : list
            The names (time series identifers) of the time series to retrieve.
            Can use sql wildcard for single time series identifier, 
            example: ts_ids =[&#34;Some.*.fully.?.path&#34;]
        units : list

            The units to return the time series in. Valid units are:

            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;EN&#34;`&lt;/span&gt;
            -- English Units
            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;SI&#34;`&lt;/span&gt;
            -- SI units
            - &lt;span&gt;actual unit of parameter&lt;/span&gt;
            -- (e.g. &#34;ft&#34;, &#34;cfs&#34;)

            If the P_Units variable has fewer positions than the p_name 
            variable, the last unit position is used for all remaning names. 
            If the units are unspecified or NULL, the NATIVE units will be 
            used for all time series.

        p_datums : str
            The vertical datums to return the units in. Valid datums are:

            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NATIVE&#34;`&lt;/span&gt;
            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NGVD29&#34;`&lt;/span&gt;
            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NAVD88&#34;`&lt;/span&gt;

        p_start : str
            The start of the time window to retrieve time series for. 
            No time series values earlier this time will be retrieved. 
            If unspecified or NULL, a value of 24 hours prior to the specified 
            or default end of the time window will be used. for the start of 
            the time window.

        p_end : str
            The end of the time window to retrieve time series for. 
            No time series values later this time will be retrieved. 
            If unspecified or NULL, the current time will be used for the end 
            of the time window.

        p_timezone : type
            The time zone to retrieve the time series in. 
            The P_Start and P_End parameters - if used - are also interpreted 
            according to this time zone. If unspecified or NULL, the UTC time 
            zone is used.
        p_office_id : type
            The office to retrieve time series for. 
            If unspecified or NULL, time series for all offices in the database 
            that match the other criteria will be retrieved.

        Returns
        -------
        pd.Core.DataFrame
            Pandas dataframe
        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; now = datetme.datetime.utcnow()
        &gt;&gt;&gt; start = (now - datetime.timedelta(10)).strftime(&#39;%Y-%m-%d&#39;)
        &gt;&gt;&gt; end = now.strftime(&#39;%Y-%m-%d&#39;)
        &gt;&gt;&gt; cwms.retrieve_time_series(ts_ids=[&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;, 
                                       &#39;Another.Fully.Qualified.Cwms.Ts.ID&#39;],
                                       p_start=start,
                                       p_end = end)


        ```
        &#34;&#34;&#34;

        p_names = &#34;|&#34;.join(ts_ids)
        p_units = &#34;|&#34;.join(units)

        cur = self.conn.cursor()

        p_results = cur.var(cx_Oracle.CLOB)
        p_date_time = cur.var(cx_Oracle.DATETIME)
        p_query_time = cur.var(int)
        p_format_time = cur.var(int)
        p_ts_count = cur.var(int)
        p_value_count = cur.var(int)

        p_format = &#34;JSON&#34;
        if p_start:
            p_start = pd.to_datetime(p_start).strftime(&#34;%Y-%m-%d&#34;)
        if p_end:
            # add one day to make it inclusive to 24:00
            p_end = (pd.to_datetime(p_end) + datetime.timedelta(days=1)).strftime(
                &#34;%Y-%m-%d&#34;
            )

        try:

            clob = cur.callproc(
                &#34;cwms_ts.retrieve_time_series&#34;,
                [
                    p_results,
                    p_date_time,
                    p_query_time,
                    p_format_time,
                    p_ts_count,
                    p_value_count,
                    p_names,
                    p_format,
                    p_units,
                    p_datums,
                    p_start,
                    p_end,
                    p_timezone,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        try:
            result = json.loads(clob[0].read())
            if as_json:
                return result
        except JSONDecodeError as e:
            LOGGER.info(&#34;No data for the requested pathnames and dates.&#34;)
            return pd.DataFrame()

        try:
            ts = result[&#34;time-series&#34;][&#34;time-series&#34;]
        except KeyError:
            LOGGER.warning(&#34;No data found&#34;)
            return pd.DataFrame()

        df_list = []
        for data in ts:
            ts_id = data[&#34;name&#34;]

            riv = data.get(&#34;regular-interval-values&#34;)
            if riv:

                segments = riv[&#34;segments&#34;]
                units = riv[&#34;unit&#34;].split(&#34; &#34;)[0]
                df_l = []
                for segment in segments:
                    first_time = segment[&#34;first-time&#34;]
                    last_time = segment[&#34;last-time&#34;]
                    value_count = segment[&#34;value-count&#34;]

                    values = segment[&#34;values&#34;]

                    date_range = pd.date_range(first_time, last_time, value_count)
                    df = pd.DataFrame(values, columns=[&#34;value&#34;, &#34;quality_code&#34;])
                    df.insert(0, &#34;date_time&#34;, date_range)
                    df_l.append(df)
                df = pd.concat(df_l)
                df[&#34;units&#34;] = units

            else:
                iiv = data[&#34;irregular-interval-values&#34;]
                units = iiv[&#34;unit&#34;].split(&#34; &#34;)[0]
                values = np.array(iiv[&#34;values&#34;])
                df = pd.DataFrame(values)
                df.columns = [&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
                df[&#34;date_time&#34;] = pd.to_datetime(df[&#34;date_time&#34;])
                df[&#34;units&#34;] = units

            df.insert(0, &#34;ts_id&#34;, ts_id)
            df_list.append(df)
        try:
            df = pd.concat(df_list)
            df[&#34;time_zone&#34;] = p_timezone
            df[&#34;value&#34;] = df[&#34;value&#34;].astype(float)
        except ValueError:
            df = pd.DataFrame()

        return df

    @LD
    def retrieve_ts(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=None,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.


        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                                start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
        &gt;&gt;&gt; df.head()
                        date_time       value  quality_code
            0 2018-12-31 08:00:00  574.831986             0
            1 2019-01-01 08:00:00  668.277580             0
            2 2019-01-02 08:00:00  608.812202             0
            3 2019-01-03 08:00:00  597.485463             0
            4 2019-01-04 08:00:00  560.673563             0
        ```
        &#34;&#34;&#34;
        p_start_time = pd.to_datetime(start_time).to_pydatetime()
        # add one day to make it inclusive to 24:00
        p_end_time = (
            pd.to_datetime(end_time) + datetime.timedelta(days=1)
        ).to_pydatetime()

        if not version_date:
            version_date = &#34;1111/11/11&#34;
            p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        else:
            p_version_date = pd.to_datetime(version_date).to_pydatetime()

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        try:

            cur.callproc(
                &#34;cwms_ts.retrieve_ts&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]
        output_len = len(output)
        LOGGER.info(f&#34;Found {output_len} records.&#34;)

        if return_df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )
            output[&#34;time_zone&#34;] = p_timezone
            output[&#34;ts_id&#34;] = p_cwms_ts_id
            if p_units:
                output[&#34;units&#34;] = p_units

        return output

    @LD
    def store_ts(
        self,
        p_cwms_ts_id,
        p_units,
        times,
        values,
        timezone,
        qualities=None,
        format=None,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database using parameter types
            compatible with cx_Oracle Pyton package.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit of the data values.
        times : list
            The times of the data values.  Can be string or type datetime
        values : list
            The data values.
        p_qualities : list
            The data quality codes for the data values.
        format : str
            strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
            parse all the way up to nanoseconds. See strftime documentation
            for more information on choices:
                https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
            store_ts will try to infer format if None.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;
        &gt;&gt;&gt; p_units = &#34;cms&#34;
        &gt;&gt;&gt; values = [1,2,3]
        &gt;&gt;&gt; p_qualities = [0,0,0]
        &gt;&gt;&gt; times = [&#39;2019/1/1&#39;,&#39;2019/1/2&#39;,&#39;2019/1/3&#39;]
        &gt;&gt;&gt; times = [datetime.datetime.strptime(x, &#34;%Y/%m/%d&#34;) for x in times]
        &gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
            True 
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        # values.insert(0, values[0])
        p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

        ts = pd.to_datetime(
            times, infer_datetime_format=True, format=format
        ).tz_localize(timezone)
        ts = [t.tz_convert(&#34;UTC&#34;) for t in ts]

        # Get the UTC times of the data values in Java milliseconds
        # this is what actually goes into Store_Ts
        zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
        p_times = [((time - zero).total_seconds() * 1000) for time in ts]
        # p_times.insert(0, p_times[0])

        if not version_date:
            p_version_date = datetime.datetime(1111, 11, 11)
        else:
            p_version_date = version_date
        if not qualities:
            p_qualities = [0 for x in p_times]
        else:
            p_qualities = qualities

        try:
            data_len = len(values)
            LOGGER.info(f&#34;Loading {data_len} values for {p_cwms_ts_id}&#34;)

            test = cur.callproc(
                &#34;cwms_ts.store_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_units,
                    p_times,
                    p_values,
                    p_qualities,
                    p_store_rule,
                    p_override_prot,
                    p_version_date,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in store_ts.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def store_by_df(
        self,
        df,
        timezone=None,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
        only_add_different=True,
    ):
        &#34;&#34;&#34;Stores time series data to the database with pandas.core.dataframe as input.

        Parameters
        ----------
        df : pandas.core.DataFrame
            Pandas DataFrame that requires `ts_id`, `date_time`, `units`,
            and `value` columns.  If optional column `quality_code` does not exist,
            all quality codes are assumed equal to 0.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.
        only_add_different : boolean
            Check what is currently in database and only commit changes

        Returns
        -------
        Boolean
            `True` for success

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_units = &#39;cms&#39;
        &gt;&gt;&gt; start_time = &#39;2019/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/8/1&#39;
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
        &gt;&gt;&gt;                     start_time=start_time,
        &gt;&gt;&gt;                     end_time=end_time,
        &gt;&gt;&gt;                     p_units=p_units
        &gt;&gt;&gt;                     )
        &gt;&gt;&gt; df[&#39;units&#39;] = p_units
        &gt;&gt;&gt; df[&#39;ts_id&#39;] = p_cwms_ts_id
        &gt;&gt;&gt; df[&#39;value&#39;] = df[&#39;value&#39;] / 1.1
        &gt;&gt;&gt; cwms.store_by_df(df)
            True
        ```

        &#34;&#34;&#34;
        df = df.copy()
        if &#34;time_zone&#34; not in df.columns and timezone:
            df[&#34;time_zone&#34;] = timezone

        if &#34;quality_code&#34; in df.columns:
            df[&#34;quality_code&#34;] = [int(x) for x in df[&#34;quality_code&#34;].values]
        else:
            df[&#34;quality_code&#34;] = 0

        # I want to make sure everything is the right type for cx_Oracle
        df[&#34;date_time&#34;] = pd.to_datetime(df[&#34;date_time&#34;])
        df[&#34;date_time&#34;] = df[&#34;date_time&#34;].dt.tz_localize(None)
        df[&#34;value&#34;] = df[&#34;value&#34;].astype(float)

        grouped = df.groupby([&#34;ts_id&#34;, &#34;units&#34;, &#34;time_zone&#34;])
        failures = 0
        for g, v in grouped:
            p_cwms_ts_id, p_units, timezone = g

            # Add a little overlap to get current data
            min_date = (v[&#34;date_time&#34;].min() - datetime.timedelta(days=1)).strftime(
                &#34;%Y/%m/%d&#34;
            )
            max_date = (v[&#34;date_time&#34;].max() + datetime.timedelta(days=1)).strftime(
                &#34;%Y/%m/%d&#34;
            )
            if only_add_different:
                # Only want to write new data to disk
                # Get current data, merge it for comparison
                # Will throw an error if time series identifier does not exist
                new_data = v.copy()
                try:

                    current_data = self.retrieve_ts(
                        p_cwms_ts_id=p_cwms_ts_id,
                        start_time=min_date,
                        end_time=max_date,
                        p_units=p_units,
                        p_timezone=timezone,
                        version_date=version_date,
                    )
                except Exception as e:
                    LOGGER.error(f&#34;Error retrieveing {p_cwms_ts_id} for comparison.&#34;)
                    current_data = pd.DataFrame()

                if not current_data.empty:
                    try:
                        merged = v.merge(
                            current_data,
                            on=[&#34;date_time&#34;, &#34;value&#34;],
                            how=&#34;outer&#34;,
                            suffixes=[&#34;&#34;, &#34;_&#34;],
                            indicator=True,
                        )
                        # The data to store after comparing to current data
                        new_data = merged[merged[&#34;_merge&#34;] == &#34;left_only&#34;]
                    except:
                        LOGGER.error(
                            f&#34;Failed to merge {p_cwms_ts_id} with existing data.&#34;
                        )
                if new_data.empty:
                    LOGGER.info(f&#34;No new data to load for {p_cwms_ts_id}&#34;)
                    # Do not want to try and load empty data so continue
                    continue
            else:
                new_data = v.copy()

            new_data_len = new_data.shape[0]
            LOGGER.info(f&#34;Loading {new_data_len} new values&#34;)

            try:
                self.store_ts(
                    p_cwms_ts_id=p_cwms_ts_id,
                    p_units=p_units,
                    timezone=timezone,
                    times=list(new_data[&#34;date_time&#34;]),
                    values=list(new_data[&#34;value&#34;].astype(float)),
                    qualities=list(new_data[&#34;quality_code&#34;]),
                    format=None,
                    p_store_rule=p_store_rule,
                    p_override_prot=p_override_prot,
                    version_date=version_date,
                    p_office_id=p_office_id,
                )
            except Exception as e:
                LOGGER.error(f&#34;Error in store_ts for {p_cwms_ts_id}&#34;)
                LOGGER.error(e)
                failures += 1
                continue
        return failures

    @LD
    def delete_ts(
        self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
    ):
        &#34;&#34;&#34;Deletes a time series from the database.

        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_delete_action : type
            Specifies what to delete.
        p_db_office_id : type
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                            &#34;DELETE TS DATA&#34;)
            True
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
            )
        except Exception as e:
            LOGGER.error(&#34;Error in delete_ts.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def rename_ts(
        self,
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
            regular interval offset.

            Restrictions on changing include:
            - New time series identifier must agree with new/existing data
                interval and offset (regular/irregular)
            - Cannot change time utc offset if from one regular offset to
                another if time series data exists

        Parameters
        ----------
        p_cwms_ts_id_old : str
            The existing time series identifier.
        p_cwms_ts_id_new : str
            The new time series identifier.
        p_utc_offset_new : int
            The new offset into the utc data interval in minutes.
        p_office_id : str
            The office that owns the time series. If not specified or NULL,
                the session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; p_cwms_ts_id_old = &#34;Some.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; p_cwms_ts_id_new = &#34;New.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; cwms.rename_ts(
            p_cwms_ts_id_old,
            p_cwms_ts_id_new,
            p_utc_offset_new=None,
            p_office_id=None
            )
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.rename_ts&#34;,
                [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in rename_ts&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def delete_ts_values(
        self,
        p_cwms_ts_id,
        p_start_time=None,
        p_end_time=None,
        p_start_time_inclusive=&#34;T&#34;,
        p_end_time_inclusive=&#34;T&#34;,
        p_override_prot=&#34;F&#34;,
        p_version_date=None,
        p_time_zone=&#34;UTC&#34;,
        date_times=[],
        p_max_version=&#34;T&#34;,
        p_ts_item_mask=-1,
        p_db_office_id=None,
    ):
        &#34;&#34;&#34;Deletes time series values for a specified time series, version date, and time window or specified times
        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_override_protection : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether to delete protected data, may also be set to &#39;E&#39; (or &#39;ERROR&#39;, 
            or anything in between) to raise an exception if protected values are encountered.
        p_start_Time : str, datetime.datetime
            The start of the time window in the specified or default time zone
        p_end_Time : str, datetime.datetime
            The end of the time window in the specified or default time zone
        p_start_time_inclusive : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether any data at the start time should be deleted (&#39;T&#39;) 
            or only data after the start time (&#39;F&#39;)
        p_end_time_inclusive : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether any data at the end time should be deleted (&#39;T&#39;) 
            or only data before the end time (&#39;F&#39;)
        p_version_date 
            The version date/time of the time series in the specified or default time zone. 
            If NULL, the earliest or latest version date will be used depending on P_Max_Version.
        p_time_zone : str
            The time zone of any/all specified times. If not specified or NULL, 
            the local time zone of the time series location is used.
        p_date_times : list of time str
            A list of specific date and times to use, instead of a time window, 
            in the specified or default time zone. Example: &#39;2019-01-01 00:20:00&#39;
        p_max_version : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether to use the earliest (&#39;F&#39;) 
            or latest (&#39;T&#39;) version date for each time if P_Version_Date is NULL.
        p_ts_item_mask : int
            A cookie specifying what time series items to purge.
        p_db_office_id : int
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..
        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                            &#34;DELETE TS DATA&#34;)
            True
        ```
        &#34;&#34;&#34;
        # if start or end time are not null override and cover to correct datetime format
        if p_start_time:
            p_start_time = pd.to_datetime(p_start_time).to_pydatetime()
        if p_end_time:
            p_end_time = pd.to_datetime(p_end_time).to_pydatetime()
        # This delete_ts method does not run if date times table is null, if no date times provided will use standard arglist (below)
        args_list = [
            p_cwms_ts_id,
            p_override_prot,
            p_start_time,
            p_end_time,
            p_start_time_inclusive,
            p_end_time_inclusive,
            p_version_date,
            p_time_zone,
        ]
        # If date times are not null modify argument list
        if date_times:
            date_table_type = self.conn.gettype(&#34;CWMS_20.DATE_TABLE_TYPE&#34;)
            p_date_times = date_table_type.newobject()
            for time_item in date_times:
                formatted_time = pd.to_datetime(time_item).to_pydatetime()
                p_date_times.append(formatted_time)
            # Append other values to arg list
            args_list += [p_date_times, p_max_version, p_ts_item_mask, p_db_office_id]

        try:
            cur = self.conn.cursor()
            LOGGER.debug(&#34;Attempting to delete&#34;)
            cur.callproc(&#34;cwms_ts.delete_ts&#34;, args_list)
        except Exception as e:
            LOGGER.error(f&#34;Error in delete_ts.{e}&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def delete_by_df(
        self,
        df,
        p_override_prot=&#34;F&#34;,
        p_version_date=None,
        p_max_version=&#34;T&#34;,
        p_ts_item_mask=-1,
        p_db_office_id=None,
    ):
        &#34;&#34;&#34;Deletes time series data with a pandas.Core.DataFrame.

        Parameters
        ----------
        df : pandas.core.DataFrame
            A pandas data frame with columns `ts_id` and `date_time`.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : type
            The version date of the data.
        p_db_office_code : type
            The unique numeric code that identifies the office that owns the time series.

        Examples
        -------
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.retrieve_ts(&#34;Some.Fully.Qualified.Cwms.pathname&#34;,&#34;2019/1/1&#34;,&#34;2019/9/1&#34;,&#34;cms&#34;,return_df=True)
        &gt;&gt;&gt; df[&#34;ts_id&#34;] = &#34;Some.Fully.Qualified.Cwms.pathname&#34;
        &gt;&gt;&gt; cwms.delete_by_df(df)
        &#34;&#34;&#34;

        grpd = df.groupby([&#34;ts_id&#34;, &#34;time_zone&#34;])
        for g, v in grpd:
            p_cwms_ts_id, p_time_zone = g

            rows, _ = v.shape
            try:
                # The below for loop is necessary bc get a db error for more than 200 vals at a time
                for i in range(int(1 + rows / 200)):
                    date_times = list(
                        pd.to_datetime(
                            v[&#34;date_time&#34;].iloc[i * 200 : (1 + i) * 200].values
                        ).to_pydatetime()
                    )
                    self.delete_ts_values(
                        p_cwms_ts_id,
                        p_start_time=None,
                        p_end_time=None,
                        p_start_time_inclusive=&#34;T&#34;,
                        p_end_time_inclusive=&#34;T&#34;,
                        p_override_prot=p_override_prot,
                        p_version_date=p_version_date,
                        p_time_zone=p_time_zone,
                        date_times=date_times,
                        p_max_version=p_max_version,
                        p_ts_item_mask=p_ts_item_mask,
                        p_db_office_id=p_db_office_id,
                    )
            except Exception as e:
                LOGGER.error(e)
                continue

    @LD
    def get_extents(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
            the database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : int
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest and latest non-null dates in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_extents(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
        ```
        &#34;&#34;&#34;

        min_date = self.get_ts_min_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        max_date = self.get_ts_max_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        return min_date, max_date

    @LD
    def get_por(
        self,
        p_cwms_ts_id,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        Returns
        -------
        pd.core.frame.DataFrame or list
            The period of record for given time series identifier

        Examples
        -------
        ```Python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.get_por(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        &gt;&gt;&gt; df.head()
                        date_time        value  quality_code
            0 1975-02-18 08:00:00   750.396435             3
            1 1975-02-19 08:00:00   750.396435             3
            2 1975-02-20 08:00:00  1403.666086             3
            3 1975-02-21 08:00:00  1613.210750             0
            4 1975-02-22 08:00:00  1765.272217             0
        ```

        &#34;&#34;&#34;

        mn, mx = self.get_extents(
            p_cwms_ts_id=p_cwms_ts_id,
            p_time_zone=p_timezone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        # To get a little overlap
        mn = mn - datetime.timedelta(days=1)
        mx = mx + datetime.timedelta(days=1)

        start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
        end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

        por = self.retrieve_ts(
            p_cwms_ts_id,
            start_time,
            end_time,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=&#34;F&#34;,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            return_df=return_df,
        )

        return por

    def compare_ts(
        self,
        p_cwms_ts_id_list,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        only_diffs=True,
    ):
        &#34;&#34;&#34;
        Compares values across list of time series identifiers.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        only_diffs : bool
            Return only differences in timestamp values (the default is True).

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID-RAW&#39;,
        &gt;&gt;&gt;                     &#39;Some.Fully.Qualified.Cwms.Ts.ID-REV&#39;]
        &gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
        &gt;&gt;&gt; df.head()

                            Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                            value       quality_code    value   quality_code
            date_time
            1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
            1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
            1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
            1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
            1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
        ```
        &#34;&#34;&#34;
        df_list = []
        for idx, p_cwms_ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[idx]
            else:
                p_units = None
            df = self.get_por(
                p_cwms_ts_id,
                p_units=p_units,
                p_timezone=p_timezone,
                p_trim=p_trim,
                p_start_inclusive=p_start_inclusive,
                p_end_inclusive=p_end_inclusive,
                p_previous=p_previous,
                p_next=p_next,
                version_date=version_date,
                p_max_version=p_max_version,
                p_office_id=p_office_id,
                return_df=True,
            )
            df.set_index(&#34;date_time&#34;, inplace=True)
            df_list.append(df)

        # reference: https://stackoverflow.com/a/47112033/4296857
        comp = pd.concat(df_list, axis=&#34;columns&#34;, keys=p_cwms_ts_id_list)
        if only_diffs:
            df_list = []
            # np.isclose only accepts 2 arrays, getting a combination of all
            # possible arrays to compare
            comb = combinations(p_cwms_ts_id_list, 2)
            for i in comb:
                a, b = i
                bol = pd.DataFrame(
                    np.isclose(comp[a][&#34;value&#34;].values, comp[b][&#34;value&#34;].values)
                    == False
                )
                df_list.append(bol)
            bol = pd.concat(df_list, axis=1).apply(
                lambda row: True in row.values, axis=1
            )
            comp = comp[bol.values]
        return comp

    @LD
    def update_ts_id(
        self,
        p_cwms_ts_id,
        p_interval_utc_offset=None,
        p_snap_forward_minutes=None,
        p_snap_backward_minutes=None,
        p_local_reg_time_zone_id=None,
        p_ts_active_flag=None,
        p_db_officeid=None,
    ):

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.update_ts_id&#34;,
                [
                    p_cwms_ts_id,
                    p_interval_utc_offset,
                    p_snap_forward_minutes,
                    p_snap_backward_minutes,
                    p_local_reg_time_zone_id,
                    p_ts_active_flag,
                    p_db_officeid,
                ],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in update_ts_id.&#34;)
            cur.close()
            raise ValueError(e)
        cur.close()
        return True

    @LD
    def create_ts(
        self,
        p_cwms_ts_id,
        p_utc_offset=None,
        p_interval_forward=None,
        p_interval_backward=None,
        p_versioned=&#34;F&#34;,
        p_active_flag=&#34;T&#34;,
        p_office_id=None,
    ):

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.create_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_utc_offset,
                    p_interval_forward,
                    p_interval_backward,
                    p_versioned,
                    p_active_flag,
                    p_office_id,
                ],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in create_ts.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cwmspy.cwms_ts.CwmsTsMixin"><code class="flex name class">
<span>class <span class="ident">CwmsTsMixin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CwmsTsMixin:
    @LD
    def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
        &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.

        Parameters
        ----------
        p_cwms_ts_id : str
            CWMS time series identifier.
        p_db_office_code : int
            The unique numeric code identifying the office
                               owning the time series

        Returns
        -------
        str
            the unique numeric code value for the specified
                time series if successful, False otherwise.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_code(&#34;Some.fully.qualified.ts.id&#34;)
            &#34;04319021&#34;

        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            ts_code = cur.callfunc(
                &#34;cwms_ts.get_ts_code&#34;,
                cx_Oracle.STRING,
                [p_cwms_ts_id, p_db_office_code],
            )
        except Exception as e:
            LOGGER.error(&#34;Error retrieving ts_code&#34;)
            cur.close()
            raise ValueError(e.__str__())
        LOGGER.info(f&#34;get_ts_code returned {ts_code}&#34;)
        cur.close()

        return ts_code

    @LD
    def get_ts_max_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The latest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.get_ts_max_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            datetime.datetime(2019, 8, 16, 7, 0)
        ```
        &#34;&#34;&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            max_date = cur.callfunc(
                &#34;cwms_ts.get_ts_max_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except Exception as e:
            cur.close()
            LOGGER.error(&#34;Error retrieving get_ts_max_date&#34;)
            raise ValueError(e.__str__())
        LOGGER.info(f&#34;max_date returned {max_date}&#34;)
        cur.close()

        return max_date

    @LD
    def get_ts_min_date(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
            database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : type
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest non-null date in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS

        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_ts_min_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)

            datetime.datetime(1975, 2, 18, 8, 0)
        ```
        &#34;&#34;&#34;

        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        cur = self.conn.cursor()
        try:

            min_date = cur.callfunc(
                &#34;cwms_ts.get_ts_min_date&#34;,
                cx_Oracle.DATETIME,
                [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in retrieving get_ts_min_date&#34;)
            cur.close()
            raise ValueError(e.__str__())
        LOGGER.info(f&#34;get_ts_min_date returned {min_date}&#34;)
        cur.close()

        return min_date

    @LD
    def get_times_for_time_window(
        self, start_time, end_time, p_ts_id, p_time_zone, p_office_id=None
    ):

        p_start_time = pd.to_datetime(start_time).to_pydatetime()
        p_end_time = pd.to_datetime(end_time).to_pydatetime()
        # FUNCTION DATE TIME EXAMPLE
        cur = self.conn.cursor()
        date_table_type = self.conn.gettype(&#34;CWMS_20.DATE_TABLE_TYPE&#34;)
        try:
            date_table_time = cur.callfunc(
                &#34;cwms_ts.get_times_for_time_window&#34;,
                date_table_type,
                [p_start_time, p_end_time, p_ts_id, p_time_zone, p_office_id],
            )
            cur.close()
            return date_table_time

        except Exception as e:
            LOGGER.error(f&#34;Error retrieving ts_code {e}&#34;)
            cur.close()
            raise ValueError(e.__str__())
        return 0

    @LD
    def retrieve_ts_out(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=None,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.


        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; df = cwms.retrieve_ts_out(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                                start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
        &gt;&gt;&gt; df.head()
             date_time  value  quality_code     time_zone                          ts_id                                       alias              units
    2020-09-01 18:00:00    0.0             0       UTC  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW    mm
    2020-09-02 00:00:00    0.0             0       UTC  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW    mm

        ```
        &#34;&#34;&#34;
        p_start_time = pd.to_datetime(start_time).to_pydatetime()
        p_end_time = pd.to_datetime(end_time).to_pydatetime()

        if not version_date:
            version_date = &#34;1111/11/11&#34;
            p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        else:
            p_version_date = pd.to_datetime(version_date).to_pydatetime()

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        p_units_out = cur.var(cx_Oracle.STRING)
        p_cwms_ts_id_out = cur.var(cx_Oracle.STRING)
        try:

            cur.callproc(
                &#34;cwms_ts.retrieve_ts_out&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id_out,
                    p_units_out,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]
        output_len = len(output)
        LOGGER.info(f&#34;Found {output_len} records.&#34;)

        if return_df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )
            output[&#34;time_zone&#34;] = p_timezone
            output[&#34;ts_id&#34;] = p_cwms_ts_id_out.getvalue()
            output[&#34;alias&#34;] = p_cwms_ts_id
            output[&#34;units&#34;] = p_units_out.getvalue()

        return output

    @LD
    def retrieve_time_series(
        self,
        ts_ids,
        units=[&#34;EN&#34;],
        p_datums=None,
        p_start=None,
        p_end=None,
        p_timezone=&#34;UTC&#34;,
        p_office_id=None,
        as_json=False,
    ):
        &#34;&#34;&#34;Retreives time series in a number of formats for a combination 
        time window, timezone, formats, and vertical datums 

        Parameters
        ----------
        ts_ids : list
            The names (time series identifers) of the time series to retrieve.
            Can use sql wildcard for single time series identifier, 
            example: ts_ids =[&#34;Some.*.fully.?.path&#34;]
        units : list

            The units to return the time series in. Valid units are:

            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;EN&#34;`&lt;/span&gt;
            -- English Units
            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;SI&#34;`&lt;/span&gt;
            -- SI units
            - &lt;span&gt;actual unit of parameter&lt;/span&gt;
            -- (e.g. &#34;ft&#34;, &#34;cfs&#34;)

            If the P_Units variable has fewer positions than the p_name 
            variable, the last unit position is used for all remaning names. 
            If the units are unspecified or NULL, the NATIVE units will be 
            used for all time series.

        p_datums : str
            The vertical datums to return the units in. Valid datums are:

            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NATIVE&#34;`&lt;/span&gt;
            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NGVD29&#34;`&lt;/span&gt;
            - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NAVD88&#34;`&lt;/span&gt;

        p_start : str
            The start of the time window to retrieve time series for. 
            No time series values earlier this time will be retrieved. 
            If unspecified or NULL, a value of 24 hours prior to the specified 
            or default end of the time window will be used. for the start of 
            the time window.

        p_end : str
            The end of the time window to retrieve time series for. 
            No time series values later this time will be retrieved. 
            If unspecified or NULL, the current time will be used for the end 
            of the time window.

        p_timezone : type
            The time zone to retrieve the time series in. 
            The P_Start and P_End parameters - if used - are also interpreted 
            according to this time zone. If unspecified or NULL, the UTC time 
            zone is used.
        p_office_id : type
            The office to retrieve time series for. 
            If unspecified or NULL, time series for all offices in the database 
            that match the other criteria will be retrieved.

        Returns
        -------
        pd.Core.DataFrame
            Pandas dataframe
        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; now = datetme.datetime.utcnow()
        &gt;&gt;&gt; start = (now - datetime.timedelta(10)).strftime(&#39;%Y-%m-%d&#39;)
        &gt;&gt;&gt; end = now.strftime(&#39;%Y-%m-%d&#39;)
        &gt;&gt;&gt; cwms.retrieve_time_series(ts_ids=[&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;, 
                                       &#39;Another.Fully.Qualified.Cwms.Ts.ID&#39;],
                                       p_start=start,
                                       p_end = end)


        ```
        &#34;&#34;&#34;

        p_names = &#34;|&#34;.join(ts_ids)
        p_units = &#34;|&#34;.join(units)

        cur = self.conn.cursor()

        p_results = cur.var(cx_Oracle.CLOB)
        p_date_time = cur.var(cx_Oracle.DATETIME)
        p_query_time = cur.var(int)
        p_format_time = cur.var(int)
        p_ts_count = cur.var(int)
        p_value_count = cur.var(int)

        p_format = &#34;JSON&#34;
        if p_start:
            p_start = pd.to_datetime(p_start).strftime(&#34;%Y-%m-%d&#34;)
        if p_end:
            # add one day to make it inclusive to 24:00
            p_end = (pd.to_datetime(p_end) + datetime.timedelta(days=1)).strftime(
                &#34;%Y-%m-%d&#34;
            )

        try:

            clob = cur.callproc(
                &#34;cwms_ts.retrieve_time_series&#34;,
                [
                    p_results,
                    p_date_time,
                    p_query_time,
                    p_format_time,
                    p_ts_count,
                    p_value_count,
                    p_names,
                    p_format,
                    p_units,
                    p_datums,
                    p_start,
                    p_end,
                    p_timezone,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        try:
            result = json.loads(clob[0].read())
            if as_json:
                return result
        except JSONDecodeError as e:
            LOGGER.info(&#34;No data for the requested pathnames and dates.&#34;)
            return pd.DataFrame()

        try:
            ts = result[&#34;time-series&#34;][&#34;time-series&#34;]
        except KeyError:
            LOGGER.warning(&#34;No data found&#34;)
            return pd.DataFrame()

        df_list = []
        for data in ts:
            ts_id = data[&#34;name&#34;]

            riv = data.get(&#34;regular-interval-values&#34;)
            if riv:

                segments = riv[&#34;segments&#34;]
                units = riv[&#34;unit&#34;].split(&#34; &#34;)[0]
                df_l = []
                for segment in segments:
                    first_time = segment[&#34;first-time&#34;]
                    last_time = segment[&#34;last-time&#34;]
                    value_count = segment[&#34;value-count&#34;]

                    values = segment[&#34;values&#34;]

                    date_range = pd.date_range(first_time, last_time, value_count)
                    df = pd.DataFrame(values, columns=[&#34;value&#34;, &#34;quality_code&#34;])
                    df.insert(0, &#34;date_time&#34;, date_range)
                    df_l.append(df)
                df = pd.concat(df_l)
                df[&#34;units&#34;] = units

            else:
                iiv = data[&#34;irregular-interval-values&#34;]
                units = iiv[&#34;unit&#34;].split(&#34; &#34;)[0]
                values = np.array(iiv[&#34;values&#34;])
                df = pd.DataFrame(values)
                df.columns = [&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
                df[&#34;date_time&#34;] = pd.to_datetime(df[&#34;date_time&#34;])
                df[&#34;units&#34;] = units

            df.insert(0, &#34;ts_id&#34;, ts_id)
            df_list.append(df)
        try:
            df = pd.concat(df_list)
            df[&#34;time_zone&#34;] = p_timezone
            df[&#34;value&#34;] = df[&#34;value&#34;].astype(float)
        except ValueError:
            df = pd.DataFrame()

        return df

    @LD
    def retrieve_ts(
        self,
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=None,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
    ):
        &#34;&#34;&#34;Retrieves time series data for a specified time series and
            time window.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier to retrieve data for.
        start_time : str &#34;%Y/%m/%d&#34;
            The start time of the time window.
        end_time : str &#34;%Y/%m/%d&#34;
            The end time of the time window.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.


        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                                start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
        &gt;&gt;&gt; df.head()
                        date_time       value  quality_code
            0 2018-12-31 08:00:00  574.831986             0
            1 2019-01-01 08:00:00  668.277580             0
            2 2019-01-02 08:00:00  608.812202             0
            3 2019-01-03 08:00:00  597.485463             0
            4 2019-01-04 08:00:00  560.673563             0
        ```
        &#34;&#34;&#34;
        p_start_time = pd.to_datetime(start_time).to_pydatetime()
        # add one day to make it inclusive to 24:00
        p_end_time = (
            pd.to_datetime(end_time) + datetime.timedelta(days=1)
        ).to_pydatetime()

        if not version_date:
            version_date = &#34;1111/11/11&#34;
            p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
        else:
            p_version_date = pd.to_datetime(version_date).to_pydatetime()

        cur = self.conn.cursor()
        p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
        try:

            cur.callproc(
                &#34;cwms_ts.retrieve_ts&#34;,
                [
                    p_at_tsv_rc,
                    p_cwms_ts_id,
                    p_units,
                    p_start_time,
                    p_end_time,
                    p_timezone,
                    p_trim,
                    p_start_inclusive,
                    p_end_inclusive,
                    p_previous,
                    p_next,
                    p_version_date,
                    p_max_version,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()

        output = [r for r in p_at_tsv_rc.getvalue()]
        output_len = len(output)
        LOGGER.info(f&#34;Found {output_len} records.&#34;)

        if return_df:
            output = pd.DataFrame(
                output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            )
            output[&#34;time_zone&#34;] = p_timezone
            output[&#34;ts_id&#34;] = p_cwms_ts_id
            if p_units:
                output[&#34;units&#34;] = p_units

        return output

    @LD
    def store_ts(
        self,
        p_cwms_ts_id,
        p_units,
        times,
        values,
        timezone,
        qualities=None,
        format=None,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Stores time series data to the database using parameter types
            compatible with cx_Oracle Pyton package.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit of the data values.
        times : list
            The times of the data values.  Can be string or type datetime
        values : list
            The data values.
        p_qualities : list
            The data quality codes for the data values.
        format : str
            strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
            parse all the way up to nanoseconds. See strftime documentation
            for more information on choices:
                https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
            store_ts will try to infer format if None.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;
        &gt;&gt;&gt; p_units = &#34;cms&#34;
        &gt;&gt;&gt; values = [1,2,3]
        &gt;&gt;&gt; p_qualities = [0,0,0]
        &gt;&gt;&gt; times = [&#39;2019/1/1&#39;,&#39;2019/1/2&#39;,&#39;2019/1/3&#39;]
        &gt;&gt;&gt; times = [datetime.datetime.strptime(x, &#34;%Y/%m/%d&#34;) for x in times]
        &gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
            True 
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        # values.insert(0, values[0])
        p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

        ts = pd.to_datetime(
            times, infer_datetime_format=True, format=format
        ).tz_localize(timezone)
        ts = [t.tz_convert(&#34;UTC&#34;) for t in ts]

        # Get the UTC times of the data values in Java milliseconds
        # this is what actually goes into Store_Ts
        zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
        p_times = [((time - zero).total_seconds() * 1000) for time in ts]
        # p_times.insert(0, p_times[0])

        if not version_date:
            p_version_date = datetime.datetime(1111, 11, 11)
        else:
            p_version_date = version_date
        if not qualities:
            p_qualities = [0 for x in p_times]
        else:
            p_qualities = qualities

        try:
            data_len = len(values)
            LOGGER.info(f&#34;Loading {data_len} values for {p_cwms_ts_id}&#34;)

            test = cur.callproc(
                &#34;cwms_ts.store_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_units,
                    p_times,
                    p_values,
                    p_qualities,
                    p_store_rule,
                    p_override_prot,
                    p_version_date,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in store_ts.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def store_by_df(
        self,
        df,
        timezone=None,
        p_store_rule=&#34;REPLACE ALL&#34;,
        p_override_prot=&#34;F&#34;,
        version_date=None,
        p_office_id=None,
        only_add_different=True,
    ):
        &#34;&#34;&#34;Stores time series data to the database with pandas.core.dataframe as input.

        Parameters
        ----------
        df : pandas.core.DataFrame
            Pandas DataFrame that requires `ts_id`, `date_time`, `units`,
            and `value` columns.  If optional column `quality_code` does not exist,
            all quality codes are assumed equal to 0.
        p_store_rule : type
            The store rule to use.
        p_override_prot : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : datetime
            Description of parameter `p_office_id`.
        p_office_id : type
            The office owning the time series. If not specified or NULL, the
            session user&#39;s default office is used.
        only_add_different : boolean
            Check what is currently in database and only commit changes

        Returns
        -------
        Boolean
            `True` for success

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; import datetime
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_units = &#39;cms&#39;
        &gt;&gt;&gt; start_time = &#39;2019/1/1&#39;
        &gt;&gt;&gt; end_time = &#39;2019/8/1&#39;
        &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
        &gt;&gt;&gt;                     start_time=start_time,
        &gt;&gt;&gt;                     end_time=end_time,
        &gt;&gt;&gt;                     p_units=p_units
        &gt;&gt;&gt;                     )
        &gt;&gt;&gt; df[&#39;units&#39;] = p_units
        &gt;&gt;&gt; df[&#39;ts_id&#39;] = p_cwms_ts_id
        &gt;&gt;&gt; df[&#39;value&#39;] = df[&#39;value&#39;] / 1.1
        &gt;&gt;&gt; cwms.store_by_df(df)
            True
        ```

        &#34;&#34;&#34;
        df = df.copy()
        if &#34;time_zone&#34; not in df.columns and timezone:
            df[&#34;time_zone&#34;] = timezone

        if &#34;quality_code&#34; in df.columns:
            df[&#34;quality_code&#34;] = [int(x) for x in df[&#34;quality_code&#34;].values]
        else:
            df[&#34;quality_code&#34;] = 0

        # I want to make sure everything is the right type for cx_Oracle
        df[&#34;date_time&#34;] = pd.to_datetime(df[&#34;date_time&#34;])
        df[&#34;date_time&#34;] = df[&#34;date_time&#34;].dt.tz_localize(None)
        df[&#34;value&#34;] = df[&#34;value&#34;].astype(float)

        grouped = df.groupby([&#34;ts_id&#34;, &#34;units&#34;, &#34;time_zone&#34;])
        failures = 0
        for g, v in grouped:
            p_cwms_ts_id, p_units, timezone = g

            # Add a little overlap to get current data
            min_date = (v[&#34;date_time&#34;].min() - datetime.timedelta(days=1)).strftime(
                &#34;%Y/%m/%d&#34;
            )
            max_date = (v[&#34;date_time&#34;].max() + datetime.timedelta(days=1)).strftime(
                &#34;%Y/%m/%d&#34;
            )
            if only_add_different:
                # Only want to write new data to disk
                # Get current data, merge it for comparison
                # Will throw an error if time series identifier does not exist
                new_data = v.copy()
                try:

                    current_data = self.retrieve_ts(
                        p_cwms_ts_id=p_cwms_ts_id,
                        start_time=min_date,
                        end_time=max_date,
                        p_units=p_units,
                        p_timezone=timezone,
                        version_date=version_date,
                    )
                except Exception as e:
                    LOGGER.error(f&#34;Error retrieveing {p_cwms_ts_id} for comparison.&#34;)
                    current_data = pd.DataFrame()

                if not current_data.empty:
                    try:
                        merged = v.merge(
                            current_data,
                            on=[&#34;date_time&#34;, &#34;value&#34;],
                            how=&#34;outer&#34;,
                            suffixes=[&#34;&#34;, &#34;_&#34;],
                            indicator=True,
                        )
                        # The data to store after comparing to current data
                        new_data = merged[merged[&#34;_merge&#34;] == &#34;left_only&#34;]
                    except:
                        LOGGER.error(
                            f&#34;Failed to merge {p_cwms_ts_id} with existing data.&#34;
                        )
                if new_data.empty:
                    LOGGER.info(f&#34;No new data to load for {p_cwms_ts_id}&#34;)
                    # Do not want to try and load empty data so continue
                    continue
            else:
                new_data = v.copy()

            new_data_len = new_data.shape[0]
            LOGGER.info(f&#34;Loading {new_data_len} new values&#34;)

            try:
                self.store_ts(
                    p_cwms_ts_id=p_cwms_ts_id,
                    p_units=p_units,
                    timezone=timezone,
                    times=list(new_data[&#34;date_time&#34;]),
                    values=list(new_data[&#34;value&#34;].astype(float)),
                    qualities=list(new_data[&#34;quality_code&#34;]),
                    format=None,
                    p_store_rule=p_store_rule,
                    p_override_prot=p_override_prot,
                    version_date=version_date,
                    p_office_id=p_office_id,
                )
            except Exception as e:
                LOGGER.error(f&#34;Error in store_ts for {p_cwms_ts_id}&#34;)
                LOGGER.error(e)
                failures += 1
                continue
        return failures

    @LD
    def delete_ts(
        self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
    ):
        &#34;&#34;&#34;Deletes a time series from the database.

        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_delete_action : type
            Specifies what to delete.
        p_db_office_id : type
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                            &#34;DELETE TS DATA&#34;)
            True
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
            )
        except Exception as e:
            LOGGER.error(&#34;Error in delete_ts.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def rename_ts(
        self,
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
            regular interval offset.

            Restrictions on changing include:
            - New time series identifier must agree with new/existing data
                interval and offset (regular/irregular)
            - Cannot change time utc offset if from one regular offset to
                another if time series data exists

        Parameters
        ----------
        p_cwms_ts_id_old : str
            The existing time series identifier.
        p_cwms_ts_id_new : str
            The new time series identifier.
        p_utc_offset_new : int
            The new offset into the utc data interval in minutes.
        p_office_id : str
            The office that owns the time series. If not specified or NULL,
                the session user&#39;s default office is used.

        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; p_cwms_ts_id_old = &#34;Some.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; p_cwms_ts_id_new = &#34;New.Fully.Qualified.Ts.ID&#34;
        &gt;&gt;&gt; cwms.rename_ts(
            p_cwms_ts_id_old,
            p_cwms_ts_id_new,
            p_utc_offset_new=None,
            p_office_id=None
            )
        ```
        &#34;&#34;&#34;

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.rename_ts&#34;,
                [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in rename_ts&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def delete_ts_values(
        self,
        p_cwms_ts_id,
        p_start_time=None,
        p_end_time=None,
        p_start_time_inclusive=&#34;T&#34;,
        p_end_time_inclusive=&#34;T&#34;,
        p_override_prot=&#34;F&#34;,
        p_version_date=None,
        p_time_zone=&#34;UTC&#34;,
        date_times=[],
        p_max_version=&#34;T&#34;,
        p_ts_item_mask=-1,
        p_db_office_id=None,
    ):
        &#34;&#34;&#34;Deletes time series values for a specified time series, version date, and time window or specified times
        Parameters
        ----------
        p_cwms_ts_id : str
            The identifier of the time series to delete.
        p_override_protection : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether to delete protected data, may also be set to &#39;E&#39; (or &#39;ERROR&#39;, 
            or anything in between) to raise an exception if protected values are encountered.
        p_start_Time : str, datetime.datetime
            The start of the time window in the specified or default time zone
        p_end_Time : str, datetime.datetime
            The end of the time window in the specified or default time zone
        p_start_time_inclusive : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether any data at the start time should be deleted (&#39;T&#39;) 
            or only data after the start time (&#39;F&#39;)
        p_end_time_inclusive : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether any data at the end time should be deleted (&#39;T&#39;) 
            or only data before the end time (&#39;F&#39;)
        p_version_date 
            The version date/time of the time series in the specified or default time zone. 
            If NULL, the earliest or latest version date will be used depending on P_Max_Version.
        p_time_zone : str
            The time zone of any/all specified times. If not specified or NULL, 
            the local time zone of the time series location is used.
        p_date_times : list of time str
            A list of specific date and times to use, instead of a time window, 
            in the specified or default time zone. Example: &#39;2019-01-01 00:20:00&#39;
        p_max_version : type
            A flag (&#39;T&#39;/&#39;F&#39;) specifying whether to use the earliest (&#39;F&#39;) 
            or latest (&#39;T&#39;) version date for each time if P_Version_Date is NULL.
        p_ts_item_mask : int
            A cookie specifying what time series items to purge.
        p_db_office_id : int
            The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office will be used..
        Returns
        -------
        Boolean
            True for success.

        Examples
        -------
        ```python
        &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                            &#34;DELETE TS DATA&#34;)
            True
        ```
        &#34;&#34;&#34;
        # if start or end time are not null override and cover to correct datetime format
        if p_start_time:
            p_start_time = pd.to_datetime(p_start_time).to_pydatetime()
        if p_end_time:
            p_end_time = pd.to_datetime(p_end_time).to_pydatetime()
        # This delete_ts method does not run if date times table is null, if no date times provided will use standard arglist (below)
        args_list = [
            p_cwms_ts_id,
            p_override_prot,
            p_start_time,
            p_end_time,
            p_start_time_inclusive,
            p_end_time_inclusive,
            p_version_date,
            p_time_zone,
        ]
        # If date times are not null modify argument list
        if date_times:
            date_table_type = self.conn.gettype(&#34;CWMS_20.DATE_TABLE_TYPE&#34;)
            p_date_times = date_table_type.newobject()
            for time_item in date_times:
                formatted_time = pd.to_datetime(time_item).to_pydatetime()
                p_date_times.append(formatted_time)
            # Append other values to arg list
            args_list += [p_date_times, p_max_version, p_ts_item_mask, p_db_office_id]

        try:
            cur = self.conn.cursor()
            LOGGER.debug(&#34;Attempting to delete&#34;)
            cur.callproc(&#34;cwms_ts.delete_ts&#34;, args_list)
        except Exception as e:
            LOGGER.error(f&#34;Error in delete_ts.{e}&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True

    @LD
    def delete_by_df(
        self,
        df,
        p_override_prot=&#34;F&#34;,
        p_version_date=None,
        p_max_version=&#34;T&#34;,
        p_ts_item_mask=-1,
        p_db_office_id=None,
    ):
        &#34;&#34;&#34;Deletes time series data with a pandas.Core.DataFrame.

        Parameters
        ----------
        df : pandas.core.DataFrame
            A pandas data frame with columns `ts_id` and `date_time`.
        p_override_protection : str
            A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
            flag on any existing data value.
        p_version_date : type
            The version date of the data.
        p_db_office_code : type
            The unique numeric code that identifies the office that owns the time series.

        Examples
        -------
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.retrieve_ts(&#34;Some.Fully.Qualified.Cwms.pathname&#34;,&#34;2019/1/1&#34;,&#34;2019/9/1&#34;,&#34;cms&#34;,return_df=True)
        &gt;&gt;&gt; df[&#34;ts_id&#34;] = &#34;Some.Fully.Qualified.Cwms.pathname&#34;
        &gt;&gt;&gt; cwms.delete_by_df(df)
        &#34;&#34;&#34;

        grpd = df.groupby([&#34;ts_id&#34;, &#34;time_zone&#34;])
        for g, v in grpd:
            p_cwms_ts_id, p_time_zone = g

            rows, _ = v.shape
            try:
                # The below for loop is necessary bc get a db error for more than 200 vals at a time
                for i in range(int(1 + rows / 200)):
                    date_times = list(
                        pd.to_datetime(
                            v[&#34;date_time&#34;].iloc[i * 200 : (1 + i) * 200].values
                        ).to_pydatetime()
                    )
                    self.delete_ts_values(
                        p_cwms_ts_id,
                        p_start_time=None,
                        p_end_time=None,
                        p_start_time_inclusive=&#34;T&#34;,
                        p_end_time_inclusive=&#34;T&#34;,
                        p_override_prot=p_override_prot,
                        p_version_date=p_version_date,
                        p_time_zone=p_time_zone,
                        date_times=date_times,
                        p_max_version=p_max_version,
                        p_ts_item_mask=p_ts_item_mask,
                        p_db_office_id=p_db_office_id,
                    )
            except Exception as e:
                LOGGER.error(e)
                continue

    @LD
    def get_extents(
        self,
        p_cwms_ts_id,
        p_time_zone=&#34;UTC&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_office_id=None,
    ):
        &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
            the database for a time series

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_time_zone : str
            The time zone in which to retrieve the latest time
            (the default is &#39;UTC&#39;).
        version_date : str
            The version date of the time series in the specified time zone
            (the default is &#39;1111/11/11&#39; which represents non-versioned).
        p_office_id : int
            Description of parameter `p_office_id` (the default is None).

        Returns
        -------
        datetime.datetime
            The earliest and latest non-null dates in the time series

        Examples
        -------
        ```python
        &gt;&gt;&gt; import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; cwms.get_extents(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
            (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
        ```
        &#34;&#34;&#34;

        min_date = self.get_ts_min_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        max_date = self.get_ts_max_date(
            p_cwms_ts_id,
            p_time_zone=p_time_zone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        return min_date, max_date

    @LD
    def get_por(
        self,
        p_cwms_ts_id,
        p_units=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        return_df=True,
    ):
        &#34;&#34;&#34;Short summary.

        Parameters
        ----------
        p_cwms_ts_id : str
            The time series identifier.
        p_units : str
            The unit to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_trim : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
            from the beginning and end of the retrieved values.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        p_version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        Returns
        -------
        pd.core.frame.DataFrame or list
            The period of record for given time series identifier

        Examples
        -------
        ```Python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; df = cwms.get_por(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        &gt;&gt;&gt; df.head()
                        date_time        value  quality_code
            0 1975-02-18 08:00:00   750.396435             3
            1 1975-02-19 08:00:00   750.396435             3
            2 1975-02-20 08:00:00  1403.666086             3
            3 1975-02-21 08:00:00  1613.210750             0
            4 1975-02-22 08:00:00  1765.272217             0
        ```

        &#34;&#34;&#34;

        mn, mx = self.get_extents(
            p_cwms_ts_id=p_cwms_ts_id,
            p_time_zone=p_timezone,
            version_date=version_date,
            p_office_id=p_office_id,
        )

        # To get a little overlap
        mn = mn - datetime.timedelta(days=1)
        mx = mx + datetime.timedelta(days=1)

        start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
        end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

        por = self.retrieve_ts(
            p_cwms_ts_id,
            start_time,
            end_time,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=&#34;F&#34;,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            return_df=return_df,
        )

        return por

    def compare_ts(
        self,
        p_cwms_ts_id_list,
        p_units_list=None,
        p_timezone=&#34;UTC&#34;,
        p_trim=&#34;F&#34;,
        p_start_inclusive=&#34;T&#34;,
        p_end_inclusive=&#34;T&#34;,
        p_previous=&#34;T&#34;,
        p_next=&#34;F&#34;,
        version_date=&#34;1111/11/11&#34;,
        p_max_version=&#34;T&#34;,
        p_office_id=None,
        only_diffs=True,
    ):
        &#34;&#34;&#34;
        Compares values across list of time series identifiers.

        Parameters
        ----------
        p_cwms_ts_id_list : list
            List of time series identifiers.
        p_units_list : list
            Unit list to retrieve the data values in.
        p_timezone : str
            The time zone for the time window and retrieved times.
        p_start_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
            on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
        p_end_inclusive : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
            (&#39;T&#39;) or before (&#39;F&#39;) the end time.
        p_previous : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
            value before the start of the time window.
        p_next : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
            value after the end of the time window.
        version_date : str
            The version date of the data to retrieve. If not specified or NULL,
            the version date is determined by P_Max_Version.
        p_max_version : str
            A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
            (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
        p_office_id : str
            The office that owns the time series.
        return_df : bool
            Return result as pandas df.
        local_tz : bool
            Return data in local timezone.
        only_diffs : bool
            Return only differences in timestamp values (the default is True).

        Returns
        -------
        list or pandas df
            Time series data, date_time, value, quality_code.

        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy.core import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
        &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID-RAW&#39;,
        &gt;&gt;&gt;                     &#39;Some.Fully.Qualified.Cwms.Ts.ID-REV&#39;]
        &gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
        &gt;&gt;&gt; df.head()

                            Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                            value       quality_code    value   quality_code
            date_time
            1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
            1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
            1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
            1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
            1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
        ```
        &#34;&#34;&#34;
        df_list = []
        for idx, p_cwms_ts_id in enumerate(p_cwms_ts_id_list):
            if p_units_list:
                p_units = p_units_list[idx]
            else:
                p_units = None
            df = self.get_por(
                p_cwms_ts_id,
                p_units=p_units,
                p_timezone=p_timezone,
                p_trim=p_trim,
                p_start_inclusive=p_start_inclusive,
                p_end_inclusive=p_end_inclusive,
                p_previous=p_previous,
                p_next=p_next,
                version_date=version_date,
                p_max_version=p_max_version,
                p_office_id=p_office_id,
                return_df=True,
            )
            df.set_index(&#34;date_time&#34;, inplace=True)
            df_list.append(df)

        # reference: https://stackoverflow.com/a/47112033/4296857
        comp = pd.concat(df_list, axis=&#34;columns&#34;, keys=p_cwms_ts_id_list)
        if only_diffs:
            df_list = []
            # np.isclose only accepts 2 arrays, getting a combination of all
            # possible arrays to compare
            comb = combinations(p_cwms_ts_id_list, 2)
            for i in comb:
                a, b = i
                bol = pd.DataFrame(
                    np.isclose(comp[a][&#34;value&#34;].values, comp[b][&#34;value&#34;].values)
                    == False
                )
                df_list.append(bol)
            bol = pd.concat(df_list, axis=1).apply(
                lambda row: True in row.values, axis=1
            )
            comp = comp[bol.values]
        return comp

    @LD
    def update_ts_id(
        self,
        p_cwms_ts_id,
        p_interval_utc_offset=None,
        p_snap_forward_minutes=None,
        p_snap_backward_minutes=None,
        p_local_reg_time_zone_id=None,
        p_ts_active_flag=None,
        p_db_officeid=None,
    ):

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.update_ts_id&#34;,
                [
                    p_cwms_ts_id,
                    p_interval_utc_offset,
                    p_snap_forward_minutes,
                    p_snap_backward_minutes,
                    p_local_reg_time_zone_id,
                    p_ts_active_flag,
                    p_db_officeid,
                ],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in update_ts_id.&#34;)
            cur.close()
            raise ValueError(e)
        cur.close()
        return True

    @LD
    def create_ts(
        self,
        p_cwms_ts_id,
        p_utc_offset=None,
        p_interval_forward=None,
        p_interval_backward=None,
        p_versioned=&#34;F&#34;,
        p_active_flag=&#34;T&#34;,
        p_office_id=None,
    ):

        cur = self.conn.cursor()
        try:

            cur.callproc(
                &#34;cwms_ts.create_ts&#34;,
                [
                    p_cwms_ts_id,
                    p_utc_offset,
                    p_interval_forward,
                    p_interval_backward,
                    p_versioned,
                    p_active_flag,
                    p_office_id,
                ],
            )
        except Exception as e:
            LOGGER.error(&#34;Error in create_ts.&#34;)
            cur.close()
            raise ValueError(e.__str__())
        cur.close()
        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cwmspy.core.CWMS" href="core.html#cwmspy.core.CWMS">CWMS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.compare_ts"><code class="name flex">
<span>def <span class="ident">compare_ts</span></span>(<span>self, p_cwms_ts_id_list, p_units_list=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, only_diffs=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Compares values across list of time series identifiers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of time series identifiers.</dd>
<dt><strong><code>p_units_list</code></strong> :&ensp;<code>list</code></dt>
<dd>Unit list to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
<dt><strong><code>local_tz</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return data in local timezone.</dd>
<dt><strong><code>only_diffs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return only differences in timestamp values (the default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> or <code>pandas df</code></dt>
<dd>Time series data, date_time, value, quality_code.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; from cwmspy.core import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; p_cwms_ts_id_list = ['Some.Fully.Qualified.Cwms.Ts.ID-RAW',
&gt;&gt;&gt;                     'Some.Fully.Qualified.Cwms.Ts.ID-REV']
&gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
&gt;&gt;&gt; df.head()

                    Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                    value       quality_code    value   quality_code
    date_time
    1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
    1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
    1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
    1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
    1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_ts(
    self,
    p_cwms_ts_id_list,
    p_units_list=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    only_diffs=True,
):
    &#34;&#34;&#34;
    Compares values across list of time series identifiers.

    Parameters
    ----------
    p_cwms_ts_id_list : list
        List of time series identifiers.
    p_units_list : list
        Unit list to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.
    local_tz : bool
        Return data in local timezone.
    only_diffs : bool
        Return only differences in timestamp values (the default is True).

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy.core import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; p_cwms_ts_id_list = [&#39;Some.Fully.Qualified.Cwms.Ts.ID-RAW&#39;,
    &gt;&gt;&gt;                     &#39;Some.Fully.Qualified.Cwms.Ts.ID-REV&#39;]
    &gt;&gt;&gt; df = cwms.compare_ts(p_cwms_ts_id_list)
    &gt;&gt;&gt; df.head()

                        Some.Fully.Qualified.Cwms.Ts.ID-RAW Some.Fully.Qualified.Cwms.Ts.ID-REV
                        value       quality_code    value   quality_code
        date_time
        1961-06-07 23:00:00 13130.521765    0.0     12852.387405    3.0
        1961-06-08 23:00:00 13521.294248    0.0     12831.936349    3.0
        1961-06-09 23:00:00 13980.027162    0.0     12811.485293    3.0
        1961-06-10 23:00:00 14181.076773    0.0     12791.034237    3.0
        1961-06-11 23:00:00 14056.482648    0.0     12770.583181    3.0
    ```
    &#34;&#34;&#34;
    df_list = []
    for idx, p_cwms_ts_id in enumerate(p_cwms_ts_id_list):
        if p_units_list:
            p_units = p_units_list[idx]
        else:
            p_units = None
        df = self.get_por(
            p_cwms_ts_id,
            p_units=p_units,
            p_timezone=p_timezone,
            p_trim=p_trim,
            p_start_inclusive=p_start_inclusive,
            p_end_inclusive=p_end_inclusive,
            p_previous=p_previous,
            p_next=p_next,
            version_date=version_date,
            p_max_version=p_max_version,
            p_office_id=p_office_id,
            return_df=True,
        )
        df.set_index(&#34;date_time&#34;, inplace=True)
        df_list.append(df)

    # reference: https://stackoverflow.com/a/47112033/4296857
    comp = pd.concat(df_list, axis=&#34;columns&#34;, keys=p_cwms_ts_id_list)
    if only_diffs:
        df_list = []
        # np.isclose only accepts 2 arrays, getting a combination of all
        # possible arrays to compare
        comb = combinations(p_cwms_ts_id_list, 2)
        for i in comb:
            a, b = i
            bol = pd.DataFrame(
                np.isclose(comp[a][&#34;value&#34;].values, comp[b][&#34;value&#34;].values)
                == False
            )
            df_list.append(bol)
        bol = pd.concat(df_list, axis=1).apply(
            lambda row: True in row.values, axis=1
        )
        comp = comp[bol.values]
    return comp</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.create_ts"><code class="name flex">
<span>def <span class="ident">create_ts</span></span>(<span>self, p_cwms_ts_id, p_utc_offset=None, p_interval_forward=None, p_interval_backward=None, p_versioned='F', p_active_flag='T', p_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def create_ts(
    self,
    p_cwms_ts_id,
    p_utc_offset=None,
    p_interval_forward=None,
    p_interval_backward=None,
    p_versioned=&#34;F&#34;,
    p_active_flag=&#34;T&#34;,
    p_office_id=None,
):

    cur = self.conn.cursor()
    try:

        cur.callproc(
            &#34;cwms_ts.create_ts&#34;,
            [
                p_cwms_ts_id,
                p_utc_offset,
                p_interval_forward,
                p_interval_backward,
                p_versioned,
                p_active_flag,
                p_office_id,
            ],
        )
    except Exception as e:
        LOGGER.error(&#34;Error in create_ts.&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_by_df"><code class="name flex">
<span>def <span class="ident">delete_by_df</span></span>(<span>self, df, p_override_prot='F', p_version_date=None, p_max_version='T', p_ts_item_mask=-1, p_db_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes time series data with a pandas.Core.DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.core.DataFrame</code></dt>
<dd>A pandas data frame with columns <code>ts_id</code> and <code>date_time</code>.</dd>
<dt><strong><code>p_override_protection</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>type</code></dt>
<dd>The version date of the data.</dd>
<dt><strong><code>p_db_office_code</code></strong> :&ensp;<code>type</code></dt>
<dd>The unique numeric code that identifies the office that owns the time series.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; df = cwms.retrieve_ts(&quot;Some.Fully.Qualified.Cwms.pathname&quot;,&quot;2019/1/1&quot;,&quot;2019/9/1&quot;,&quot;cms&quot;,return_df=True)
&gt;&gt;&gt; df[&quot;ts_id&quot;] = &quot;Some.Fully.Qualified.Cwms.pathname&quot;
&gt;&gt;&gt; cwms.delete_by_df(df)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def delete_by_df(
    self,
    df,
    p_override_prot=&#34;F&#34;,
    p_version_date=None,
    p_max_version=&#34;T&#34;,
    p_ts_item_mask=-1,
    p_db_office_id=None,
):
    &#34;&#34;&#34;Deletes time series data with a pandas.Core.DataFrame.

    Parameters
    ----------
    df : pandas.core.DataFrame
        A pandas data frame with columns `ts_id` and `date_time`.
    p_override_protection : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : type
        The version date of the data.
    p_db_office_code : type
        The unique numeric code that identifies the office that owns the time series.

    Examples
    -------
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; df = cwms.retrieve_ts(&#34;Some.Fully.Qualified.Cwms.pathname&#34;,&#34;2019/1/1&#34;,&#34;2019/9/1&#34;,&#34;cms&#34;,return_df=True)
    &gt;&gt;&gt; df[&#34;ts_id&#34;] = &#34;Some.Fully.Qualified.Cwms.pathname&#34;
    &gt;&gt;&gt; cwms.delete_by_df(df)
    &#34;&#34;&#34;

    grpd = df.groupby([&#34;ts_id&#34;, &#34;time_zone&#34;])
    for g, v in grpd:
        p_cwms_ts_id, p_time_zone = g

        rows, _ = v.shape
        try:
            # The below for loop is necessary bc get a db error for more than 200 vals at a time
            for i in range(int(1 + rows / 200)):
                date_times = list(
                    pd.to_datetime(
                        v[&#34;date_time&#34;].iloc[i * 200 : (1 + i) * 200].values
                    ).to_pydatetime()
                )
                self.delete_ts_values(
                    p_cwms_ts_id,
                    p_start_time=None,
                    p_end_time=None,
                    p_start_time_inclusive=&#34;T&#34;,
                    p_end_time_inclusive=&#34;T&#34;,
                    p_override_prot=p_override_prot,
                    p_version_date=p_version_date,
                    p_time_zone=p_time_zone,
                    date_times=date_times,
                    p_max_version=p_max_version,
                    p_ts_item_mask=p_ts_item_mask,
                    p_db_office_id=p_db_office_id,
                )
        except Exception as e:
            LOGGER.error(e)
            continue</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_ts"><code class="name flex">
<span>def <span class="ident">delete_ts</span></span>(<span>self, p_cwms_ts_id, p_delete_action='DELETE TS ID', p_db_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a time series from the database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifier of the time series to delete.</dd>
<dt><strong><code>p_delete_action</code></strong> :&ensp;<code>type</code></dt>
<dd>Specifies what to delete.</dd>
<dt><strong><code>p_db_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office that owns the time series. If not specified or NULL,
the session user's default office will be used..</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; cwms.delete_ts(&quot;Some.Fully.Qualified.Cwms.Ts.Id&quot;,
                    &quot;DELETE TS DATA&quot;)
    True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def delete_ts(
    self, p_cwms_ts_id, p_delete_action=&#34;DELETE TS ID&#34;, p_db_office_id=None
):
    &#34;&#34;&#34;Deletes a time series from the database.

    Parameters
    ----------
    p_cwms_ts_id : str
        The identifier of the time series to delete.
    p_delete_action : type
        Specifies what to delete.
    p_db_office_id : type
        The office that owns the time series. If not specified or NULL,
        the session user&#39;s default office will be used..

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                        &#34;DELETE TS DATA&#34;)
        True
    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:

        cur.callproc(
            &#34;cwms_ts.delete_ts&#34;, [p_cwms_ts_id, p_delete_action, p_db_office_id]
        )
    except Exception as e:
        LOGGER.error(&#34;Error in delete_ts.&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.delete_ts_values"><code class="name flex">
<span>def <span class="ident">delete_ts_values</span></span>(<span>self, p_cwms_ts_id, p_start_time=None, p_end_time=None, p_start_time_inclusive='T', p_end_time_inclusive='T', p_override_prot='F', p_version_date=None, p_time_zone='UTC', date_times=[], p_max_version='T', p_ts_item_mask=-1, p_db_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes time series values for a specified time series, version date, and time window or specified times
Parameters</p>
<hr>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifier of the time series to delete.</dd>
<dt><strong><code>p_override_protection</code></strong> :&ensp;<code>type</code></dt>
<dd>A flag ('T'/'F') specifying whether to delete protected data, may also be set to 'E' (or 'ERROR',
or anything in between) to raise an exception if protected values are encountered.</dd>
<dt><strong><code>p_start_Time</code></strong> :&ensp;<code>str, datetime.datetime</code></dt>
<dd>The start of the time window in the specified or default time zone</dd>
<dt><strong><code>p_end_Time</code></strong> :&ensp;<code>str, datetime.datetime</code></dt>
<dd>The end of the time window in the specified or default time zone</dd>
<dt><strong><code>p_start_time_inclusive</code></strong> :&ensp;<code>type</code></dt>
<dd>A flag ('T'/'F') specifying whether any data at the start time should be deleted ('T')
or only data after the start time ('F')</dd>
<dt><strong><code>p_end_time_inclusive</code></strong> :&ensp;<code>type</code></dt>
<dd>A flag ('T'/'F') specifying whether any data at the end time should be deleted ('T')
or only data before the end time ('F')</dd>
<dt>p_version_date</dt>
<dt>The version date/time of the time series in the specified or default time zone.</dt>
<dt>If NULL, the earliest or latest version date will be used depending on P_Max_Version.</dt>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone of any/all specified times. If not specified or NULL,
the local time zone of the time series location is used.</dd>
<dt><strong><code>p_date_times</code></strong> :&ensp;<code>list</code> of <code>time str</code></dt>
<dd>A list of specific date and times to use, instead of a time window,
in the specified or default time zone. Example: '2019-01-01 00:20:00'</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>type</code></dt>
<dd>A flag ('T'/'F') specifying whether to use the earliest ('F')
or latest ('T') version date for each time if P_Version_Date is NULL.</dd>
<dt><strong><code>p_ts_item_mask</code></strong> :&ensp;<code>int</code></dt>
<dd>A cookie specifying what time series items to purge.</dd>
<dt><strong><code>p_db_office_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The office that owns the time series. If not specified or NULL,
the session user's default office will be used..</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; cwms.delete_ts(&quot;Some.Fully.Qualified.Cwms.Ts.Id&quot;,
                    &quot;DELETE TS DATA&quot;)
    True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def delete_ts_values(
    self,
    p_cwms_ts_id,
    p_start_time=None,
    p_end_time=None,
    p_start_time_inclusive=&#34;T&#34;,
    p_end_time_inclusive=&#34;T&#34;,
    p_override_prot=&#34;F&#34;,
    p_version_date=None,
    p_time_zone=&#34;UTC&#34;,
    date_times=[],
    p_max_version=&#34;T&#34;,
    p_ts_item_mask=-1,
    p_db_office_id=None,
):
    &#34;&#34;&#34;Deletes time series values for a specified time series, version date, and time window or specified times
    Parameters
    ----------
    p_cwms_ts_id : str
        The identifier of the time series to delete.
    p_override_protection : type
        A flag (&#39;T&#39;/&#39;F&#39;) specifying whether to delete protected data, may also be set to &#39;E&#39; (or &#39;ERROR&#39;, 
        or anything in between) to raise an exception if protected values are encountered.
    p_start_Time : str, datetime.datetime
        The start of the time window in the specified or default time zone
    p_end_Time : str, datetime.datetime
        The end of the time window in the specified or default time zone
    p_start_time_inclusive : type
        A flag (&#39;T&#39;/&#39;F&#39;) specifying whether any data at the start time should be deleted (&#39;T&#39;) 
        or only data after the start time (&#39;F&#39;)
    p_end_time_inclusive : type
        A flag (&#39;T&#39;/&#39;F&#39;) specifying whether any data at the end time should be deleted (&#39;T&#39;) 
        or only data before the end time (&#39;F&#39;)
    p_version_date 
        The version date/time of the time series in the specified or default time zone. 
        If NULL, the earliest or latest version date will be used depending on P_Max_Version.
    p_time_zone : str
        The time zone of any/all specified times. If not specified or NULL, 
        the local time zone of the time series location is used.
    p_date_times : list of time str
        A list of specific date and times to use, instead of a time window, 
        in the specified or default time zone. Example: &#39;2019-01-01 00:20:00&#39;
    p_max_version : type
        A flag (&#39;T&#39;/&#39;F&#39;) specifying whether to use the earliest (&#39;F&#39;) 
        or latest (&#39;T&#39;) version date for each time if P_Version_Date is NULL.
    p_ts_item_mask : int
        A cookie specifying what time series items to purge.
    p_db_office_id : int
        The office that owns the time series. If not specified or NULL,
        the session user&#39;s default office will be used..
    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; cwms.delete_ts(&#34;Some.Fully.Qualified.Cwms.Ts.Id&#34;,
                        &#34;DELETE TS DATA&#34;)
        True
    ```
    &#34;&#34;&#34;
    # if start or end time are not null override and cover to correct datetime format
    if p_start_time:
        p_start_time = pd.to_datetime(p_start_time).to_pydatetime()
    if p_end_time:
        p_end_time = pd.to_datetime(p_end_time).to_pydatetime()
    # This delete_ts method does not run if date times table is null, if no date times provided will use standard arglist (below)
    args_list = [
        p_cwms_ts_id,
        p_override_prot,
        p_start_time,
        p_end_time,
        p_start_time_inclusive,
        p_end_time_inclusive,
        p_version_date,
        p_time_zone,
    ]
    # If date times are not null modify argument list
    if date_times:
        date_table_type = self.conn.gettype(&#34;CWMS_20.DATE_TABLE_TYPE&#34;)
        p_date_times = date_table_type.newobject()
        for time_item in date_times:
            formatted_time = pd.to_datetime(time_item).to_pydatetime()
            p_date_times.append(formatted_time)
        # Append other values to arg list
        args_list += [p_date_times, p_max_version, p_ts_item_mask, p_db_office_id]

    try:
        cur = self.conn.cursor()
        LOGGER.debug(&#34;Attempting to delete&#34;)
        cur.callproc(&#34;cwms_ts.delete_ts&#34;, args_list)
    except Exception as e:
        LOGGER.error(f&#34;Error in delete_ts.{e}&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_extents"><code class="name flex">
<span>def <span class="ident">get_extents</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the earliest and latest non-null time series data date in
the database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The earliest and latest non-null dates in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; cwms.get_extents('Some.Fully.Qualified.Cwms.Ts.ID')
    (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def get_extents(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the earliest and latest non-null time series data date in
        the database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : int
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The earliest and latest non-null dates in the time series

    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; cwms.get_extents(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        (datetime.datetime(1975, 2, 18, 8, 0), datetime.datetime(2019, 8, 16, 7, 0))
    ```
    &#34;&#34;&#34;

    min_date = self.get_ts_min_date(
        p_cwms_ts_id,
        p_time_zone=p_time_zone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    max_date = self.get_ts_max_date(
        p_cwms_ts_id,
        p_time_zone=p_time_zone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    return min_date, max_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_por"><code class="name flex">
<span>def <span class="ident">get_por</span></span>(<span>self, p_cwms_ts_id, p_units=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date='1111/11/11', p_max_version='T', p_office_id=None, return_df=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Short summary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_trim</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to trim missing values
from the beginning and end of the retrieved values.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.core.frame.DataFrame</code> or <code>list</code></dt>
<dd>The period of record for given time series identifier</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-Python">&gt;&gt;&gt; from cwmspy.core import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; df = cwms.get_por('Some.Fully.Qualified.Cwms.Ts.ID')
&gt;&gt;&gt; df.head()
                date_time        value  quality_code
    0 1975-02-18 08:00:00   750.396435             3
    1 1975-02-19 08:00:00   750.396435             3
    2 1975-02-20 08:00:00  1403.666086             3
    3 1975-02-21 08:00:00  1613.210750             0
    4 1975-02-22 08:00:00  1765.272217             0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def get_por(
    self,
    p_cwms_ts_id,
    p_units=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    return_df=True,
):
    &#34;&#34;&#34;Short summary.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_units : str
        The unit to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_trim : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
        from the beginning and end of the retrieved values.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    p_version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.
    Returns
    -------
    pd.core.frame.DataFrame or list
        The period of record for given time series identifier

    Examples
    -------
    ```Python
    &gt;&gt;&gt; from cwmspy.core import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; df = cwms.get_por(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
    &gt;&gt;&gt; df.head()
                    date_time        value  quality_code
        0 1975-02-18 08:00:00   750.396435             3
        1 1975-02-19 08:00:00   750.396435             3
        2 1975-02-20 08:00:00  1403.666086             3
        3 1975-02-21 08:00:00  1613.210750             0
        4 1975-02-22 08:00:00  1765.272217             0
    ```

    &#34;&#34;&#34;

    mn, mx = self.get_extents(
        p_cwms_ts_id=p_cwms_ts_id,
        p_time_zone=p_timezone,
        version_date=version_date,
        p_office_id=p_office_id,
    )

    # To get a little overlap
    mn = mn - datetime.timedelta(days=1)
    mx = mx + datetime.timedelta(days=1)

    start_time = mn.strftime(&#34;%Y/%m/%d&#34;)
    end_time = mx.strftime(&#34;%Y/%m/%d&#34;)

    por = self.retrieve_ts(
        p_cwms_ts_id,
        start_time,
        end_time,
        p_units=p_units,
        p_timezone=p_timezone,
        p_trim=&#34;F&#34;,
        p_start_inclusive=p_start_inclusive,
        p_end_inclusive=p_end_inclusive,
        p_previous=p_previous,
        p_next=p_next,
        version_date=version_date,
        p_max_version=p_max_version,
        p_office_id=p_office_id,
        return_df=return_df,
    )

    return por</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_times_for_time_window"><code class="name flex">
<span>def <span class="ident">get_times_for_time_window</span></span>(<span>self, start_time, end_time, p_ts_id, p_time_zone, p_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def get_times_for_time_window(
    self, start_time, end_time, p_ts_id, p_time_zone, p_office_id=None
):

    p_start_time = pd.to_datetime(start_time).to_pydatetime()
    p_end_time = pd.to_datetime(end_time).to_pydatetime()
    # FUNCTION DATE TIME EXAMPLE
    cur = self.conn.cursor()
    date_table_type = self.conn.gettype(&#34;CWMS_20.DATE_TABLE_TYPE&#34;)
    try:
        date_table_time = cur.callfunc(
            &#34;cwms_ts.get_times_for_time_window&#34;,
            date_table_type,
            [p_start_time, p_end_time, p_ts_id, p_time_zone, p_office_id],
        )
        cur.close()
        return date_table_time

    except Exception as e:
        LOGGER.error(f&#34;Error retrieving ts_code {e}&#34;)
        cur.close()
        raise ValueError(e.__str__())
    return 0</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_code"><code class="name flex">
<span>def <span class="ident">get_ts_code</span></span>(<span>self, p_cwms_ts_id, p_db_office_code=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the CWMS TS Code of a given pathname.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>CWMS time series identifier.</dd>
<dt><strong><code>p_db_office_code</code></strong> :&ensp;<code>int</code></dt>
<dd>The unique numeric code identifying the office
owning the time series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the unique numeric code value for the specified
time series if successful, False otherwise.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; cwms.get_ts_code(&quot;Some.fully.qualified.ts.id&quot;)
    &quot;04319021&quot;

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def get_ts_code(self, p_cwms_ts_id, p_db_office_code=None):
    &#34;&#34;&#34;Get the CWMS TS Code of a given pathname.

    Parameters
    ----------
    p_cwms_ts_id : str
        CWMS time series identifier.
    p_db_office_code : int
        The unique numeric code identifying the office
                           owning the time series

    Returns
    -------
    str
        the unique numeric code value for the specified
            time series if successful, False otherwise.

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; cwms.get_ts_code(&#34;Some.fully.qualified.ts.id&#34;)
        &#34;04319021&#34;

    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:

        ts_code = cur.callfunc(
            &#34;cwms_ts.get_ts_code&#34;,
            cx_Oracle.STRING,
            [p_cwms_ts_id, p_db_office_code],
        )
    except Exception as e:
        LOGGER.error(&#34;Error retrieving ts_code&#34;)
        cur.close()
        raise ValueError(e.__str__())
    LOGGER.info(f&#34;get_ts_code returned {ts_code}&#34;)
    cur.close()

    return ts_code</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date"><code class="name flex">
<span>def <span class="ident">get_ts_max_date</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the latest non-null time series data date in the
database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The latest non-null date in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; cwms.get_ts_max_date('Some.Fully.Qualified.Cwms.Ts.ID')
    datetime.datetime(2019, 8, 16, 7, 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def get_ts_max_date(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the latest non-null time series data date in the
        database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : type
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The latest non-null date in the time series

    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; cwms.get_ts_max_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)
        datetime.datetime(2019, 8, 16, 7, 0)
    ```
    &#34;&#34;&#34;
    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    cur = self.conn.cursor()
    try:

        max_date = cur.callfunc(
            &#34;cwms_ts.get_ts_max_date&#34;,
            cx_Oracle.DATETIME,
            [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
        )
    except Exception as e:
        cur.close()
        LOGGER.error(&#34;Error retrieving get_ts_max_date&#34;)
        raise ValueError(e.__str__())
    LOGGER.info(f&#34;max_date returned {max_date}&#34;)
    cur.close()

    return max_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date"><code class="name flex">
<span>def <span class="ident">get_ts_min_date</span></span>(<span>self, p_cwms_ts_id, p_time_zone='UTC', version_date='1111/11/11', p_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the earliest non-null time series data date in the
database for a time series</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_time_zone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone in which to retrieve the latest time
(the default is 'UTC').</dd>
<dt><strong><code>version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the time series in the specified time zone
(the default is '1111/11/11' which represents non-versioned).</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>Description of parameter <code>p_office_id</code> (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime.datetime</code></dt>
<dd>The earliest non-null date in the time series</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import CWMS

&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; cwms.get_ts_min_date('Some.Fully.Qualified.Cwms.Ts.ID')

    datetime.datetime(1975, 2, 18, 8, 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def get_ts_min_date(
    self,
    p_cwms_ts_id,
    p_time_zone=&#34;UTC&#34;,
    version_date=&#34;1111/11/11&#34;,
    p_office_id=None,
):
    &#34;&#34;&#34;Retrieves the earliest non-null time series data date in the
        database for a time series

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_time_zone : str
        The time zone in which to retrieve the latest time
        (the default is &#39;UTC&#39;).
    version_date : str
        The version date of the time series in the specified time zone
        (the default is &#39;1111/11/11&#39; which represents non-versioned).
    p_office_id : type
        Description of parameter `p_office_id` (the default is None).

    Returns
    -------
    datetime.datetime
        The earliest non-null date in the time series

    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS

    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; cwms.get_ts_min_date(&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;)

        datetime.datetime(1975, 2, 18, 8, 0)
    ```
    &#34;&#34;&#34;

    p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    cur = self.conn.cursor()
    try:

        min_date = cur.callfunc(
            &#34;cwms_ts.get_ts_min_date&#34;,
            cx_Oracle.DATETIME,
            [p_cwms_ts_id, p_time_zone, p_version_date, p_office_id],
        )
    except Exception as e:
        LOGGER.error(&#34;Error in retrieving get_ts_min_date&#34;)
        cur.close()
        raise ValueError(e.__str__())
    LOGGER.info(f&#34;get_ts_min_date returned {min_date}&#34;)
    cur.close()

    return min_date</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.rename_ts"><code class="name flex">
<span>def <span class="ident">rename_ts</span></span>(<span>self, p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new=None, p_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Renames a time series in the database, optionally setting a new
regular interval offset.</p>
<pre><code>Restrictions on changing include:
- New time series identifier must agree with new/existing data
    interval and offset (regular/irregular)
- Cannot change time utc offset if from one regular offset to
    another if time series data exists
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id_old</code></strong> :&ensp;<code>str</code></dt>
<dd>The existing time series identifier.</dd>
<dt><strong><code>p_cwms_ts_id_new</code></strong> :&ensp;<code>str</code></dt>
<dd>The new time series identifier.</dd>
<dt><strong><code>p_utc_offset_new</code></strong> :&ensp;<code>int</code></dt>
<dd>The new offset into the utc data interval in minutes.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series. If not specified or NULL,
the session user's default office is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; p_cwms_ts_id_old = &quot;Some.Fully.Qualified.Ts.ID&quot;
&gt;&gt;&gt; p_cwms_ts_id_new = &quot;New.Fully.Qualified.Ts.ID&quot;
&gt;&gt;&gt; cwms.rename_ts(
    p_cwms_ts_id_old,
    p_cwms_ts_id_new,
    p_utc_offset_new=None,
    p_office_id=None
    )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def rename_ts(
    self,
    p_cwms_ts_id_old,
    p_cwms_ts_id_new,
    p_utc_offset_new=None,
    p_office_id=None,
):
    &#34;&#34;&#34;Renames a time series in the database, optionally setting a new
        regular interval offset.

        Restrictions on changing include:
        - New time series identifier must agree with new/existing data
            interval and offset (regular/irregular)
        - Cannot change time utc offset if from one regular offset to
            another if time series data exists

    Parameters
    ----------
    p_cwms_ts_id_old : str
        The existing time series identifier.
    p_cwms_ts_id_new : str
        The new time series identifier.
    p_utc_offset_new : int
        The new offset into the utc data interval in minutes.
    p_office_id : str
        The office that owns the time series. If not specified or NULL,
            the session user&#39;s default office is used.

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; p_cwms_ts_id_old = &#34;Some.Fully.Qualified.Ts.ID&#34;
    &gt;&gt;&gt; p_cwms_ts_id_new = &#34;New.Fully.Qualified.Ts.ID&#34;
    &gt;&gt;&gt; cwms.rename_ts(
        p_cwms_ts_id_old,
        p_cwms_ts_id_new,
        p_utc_offset_new=None,
        p_office_id=None
        )
    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()
    try:

        cur.callproc(
            &#34;cwms_ts.rename_ts&#34;,
            [p_cwms_ts_id_old, p_cwms_ts_id_new, p_utc_offset_new, p_office_id],
        )
    except Exception as e:
        LOGGER.error(&#34;Error in rename_ts&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.retrieve_time_series"><code class="name flex">
<span>def <span class="ident">retrieve_time_series</span></span>(<span>self, ts_ids, units=['EN'], p_datums=None, p_start=None, p_end=None, p_timezone='UTC', p_office_id=None, as_json=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retreives time series in a number of formats for a combination
time window, timezone, formats, and vertical datums </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts_ids</code></strong> :&ensp;<code>list</code></dt>
<dd>The names (time series identifers) of the time series to retrieve.
Can use sql wildcard for single time series identifier,
example: ts_ids =["Some.*.fully.?.path"]</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>list</code></dt>
<dd>
<p>The units to return the time series in. Valid units are:</p>
<ul>
<li><span style="color:#bf2419"><code>"EN"</code></span>
&ndash; English Units</li>
<li><span style="color:#bf2419"><code>"SI"</code></span>
&ndash; SI units</li>
<li><span>actual unit of parameter</span>
&ndash; (e.g. "ft", "cfs")</li>
</ul>
<p>If the P_Units variable has fewer positions than the p_name
variable, the last unit position is used for all remaning names.
If the units are unspecified or NULL, the NATIVE units will be
used for all time series.</p>
</dd>
<dt><strong><code>p_datums</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The vertical datums to return the units in. Valid datums are:</p>
<ul>
<li><span style="color:#bf2419"><code>"NATIVE"</code></span></li>
<li><span style="color:#bf2419"><code>"NGVD29"</code></span></li>
<li><span style="color:#bf2419"><code>"NAVD88"</code></span></li>
</ul>
</dd>
<dt><strong><code>p_start</code></strong> :&ensp;<code>str</code></dt>
<dd>The start of the time window to retrieve time series for.
No time series values earlier this time will be retrieved.
If unspecified or NULL, a value of 24 hours prior to the specified
or default end of the time window will be used. for the start of
the time window.</dd>
<dt><strong><code>p_end</code></strong> :&ensp;<code>str</code></dt>
<dd>The end of the time window to retrieve time series for.
No time series values later this time will be retrieved.
If unspecified or NULL, the current time will be used for the end
of the time window.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>type</code></dt>
<dd>The time zone to retrieve the time series in.
The P_Start and P_End parameters - if used - are also interpreted
according to this time zone. If unspecified or NULL, the UTC time
zone is used.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office to retrieve time series for.
If unspecified or NULL, time series for all offices in the database
that match the other criteria will be retrieved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.Core.DataFrame</code></dt>
<dd>Pandas dataframe</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import CWMS
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; now = datetme.datetime.utcnow()
&gt;&gt;&gt; start = (now - datetime.timedelta(10)).strftime('%Y-%m-%d')
&gt;&gt;&gt; end = now.strftime('%Y-%m-%d')
&gt;&gt;&gt; cwms.retrieve_time_series(ts_ids=['Some.Fully.Qualified.Cwms.Ts.ID', 
                               'Another.Fully.Qualified.Cwms.Ts.ID'],
                               p_start=start,
                               p_end = end)


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def retrieve_time_series(
    self,
    ts_ids,
    units=[&#34;EN&#34;],
    p_datums=None,
    p_start=None,
    p_end=None,
    p_timezone=&#34;UTC&#34;,
    p_office_id=None,
    as_json=False,
):
    &#34;&#34;&#34;Retreives time series in a number of formats for a combination 
    time window, timezone, formats, and vertical datums 

    Parameters
    ----------
    ts_ids : list
        The names (time series identifers) of the time series to retrieve.
        Can use sql wildcard for single time series identifier, 
        example: ts_ids =[&#34;Some.*.fully.?.path&#34;]
    units : list

        The units to return the time series in. Valid units are:

        - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;EN&#34;`&lt;/span&gt;
        -- English Units
        - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;SI&#34;`&lt;/span&gt;
        -- SI units
        - &lt;span&gt;actual unit of parameter&lt;/span&gt;
        -- (e.g. &#34;ft&#34;, &#34;cfs&#34;)

        If the P_Units variable has fewer positions than the p_name 
        variable, the last unit position is used for all remaning names. 
        If the units are unspecified or NULL, the NATIVE units will be 
        used for all time series.

    p_datums : str
        The vertical datums to return the units in. Valid datums are:

        - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NATIVE&#34;`&lt;/span&gt;
        - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NGVD29&#34;`&lt;/span&gt;
        - &lt;span style=&#34;color:#bf2419&#34;&gt;`&#34;NAVD88&#34;`&lt;/span&gt;

    p_start : str
        The start of the time window to retrieve time series for. 
        No time series values earlier this time will be retrieved. 
        If unspecified or NULL, a value of 24 hours prior to the specified 
        or default end of the time window will be used. for the start of 
        the time window.

    p_end : str
        The end of the time window to retrieve time series for. 
        No time series values later this time will be retrieved. 
        If unspecified or NULL, the current time will be used for the end 
        of the time window.

    p_timezone : type
        The time zone to retrieve the time series in. 
        The P_Start and P_End parameters - if used - are also interpreted 
        according to this time zone. If unspecified or NULL, the UTC time 
        zone is used.
    p_office_id : type
        The office to retrieve time series for. 
        If unspecified or NULL, time series for all offices in the database 
        that match the other criteria will be retrieved.

    Returns
    -------
    pd.Core.DataFrame
        Pandas dataframe
    Examples
    -------
    ```python
    &gt;&gt;&gt; import CWMS
    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; now = datetme.datetime.utcnow()
    &gt;&gt;&gt; start = (now - datetime.timedelta(10)).strftime(&#39;%Y-%m-%d&#39;)
    &gt;&gt;&gt; end = now.strftime(&#39;%Y-%m-%d&#39;)
    &gt;&gt;&gt; cwms.retrieve_time_series(ts_ids=[&#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;, 
                                   &#39;Another.Fully.Qualified.Cwms.Ts.ID&#39;],
                                   p_start=start,
                                   p_end = end)


    ```
    &#34;&#34;&#34;

    p_names = &#34;|&#34;.join(ts_ids)
    p_units = &#34;|&#34;.join(units)

    cur = self.conn.cursor()

    p_results = cur.var(cx_Oracle.CLOB)
    p_date_time = cur.var(cx_Oracle.DATETIME)
    p_query_time = cur.var(int)
    p_format_time = cur.var(int)
    p_ts_count = cur.var(int)
    p_value_count = cur.var(int)

    p_format = &#34;JSON&#34;
    if p_start:
        p_start = pd.to_datetime(p_start).strftime(&#34;%Y-%m-%d&#34;)
    if p_end:
        # add one day to make it inclusive to 24:00
        p_end = (pd.to_datetime(p_end) + datetime.timedelta(days=1)).strftime(
            &#34;%Y-%m-%d&#34;
        )

    try:

        clob = cur.callproc(
            &#34;cwms_ts.retrieve_time_series&#34;,
            [
                p_results,
                p_date_time,
                p_query_time,
                p_format_time,
                p_ts_count,
                p_value_count,
                p_names,
                p_format,
                p_units,
                p_datums,
                p_start,
                p_end,
                p_timezone,
                p_office_id,
            ],
        )

    except Exception as e:
        LOGGER.error(&#34;Error in retrieving time series&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    try:
        result = json.loads(clob[0].read())
        if as_json:
            return result
    except JSONDecodeError as e:
        LOGGER.info(&#34;No data for the requested pathnames and dates.&#34;)
        return pd.DataFrame()

    try:
        ts = result[&#34;time-series&#34;][&#34;time-series&#34;]
    except KeyError:
        LOGGER.warning(&#34;No data found&#34;)
        return pd.DataFrame()

    df_list = []
    for data in ts:
        ts_id = data[&#34;name&#34;]

        riv = data.get(&#34;regular-interval-values&#34;)
        if riv:

            segments = riv[&#34;segments&#34;]
            units = riv[&#34;unit&#34;].split(&#34; &#34;)[0]
            df_l = []
            for segment in segments:
                first_time = segment[&#34;first-time&#34;]
                last_time = segment[&#34;last-time&#34;]
                value_count = segment[&#34;value-count&#34;]

                values = segment[&#34;values&#34;]

                date_range = pd.date_range(first_time, last_time, value_count)
                df = pd.DataFrame(values, columns=[&#34;value&#34;, &#34;quality_code&#34;])
                df.insert(0, &#34;date_time&#34;, date_range)
                df_l.append(df)
            df = pd.concat(df_l)
            df[&#34;units&#34;] = units

        else:
            iiv = data[&#34;irregular-interval-values&#34;]
            units = iiv[&#34;unit&#34;].split(&#34; &#34;)[0]
            values = np.array(iiv[&#34;values&#34;])
            df = pd.DataFrame(values)
            df.columns = [&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            df[&#34;date_time&#34;] = pd.to_datetime(df[&#34;date_time&#34;])
            df[&#34;units&#34;] = units

        df.insert(0, &#34;ts_id&#34;, ts_id)
        df_list.append(df)
    try:
        df = pd.concat(df_list)
        df[&#34;time_zone&#34;] = p_timezone
        df[&#34;value&#34;] = df[&#34;value&#34;].astype(float)
    except ValueError:
        df = pd.DataFrame()

    return df</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts"><code class="name flex">
<span>def <span class="ident">retrieve_ts</span></span>(<span>self, p_cwms_ts_id, start_time, end_time, p_units=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date=None, p_max_version='T', p_office_id=None, return_df=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves time series data for a specified time series and
time window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier to retrieve data for.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>str "%Y/%m/%d"</code></dt>
<dd>The start time of the time window.</dd>
<dt><strong><code>end_time</code></strong> :&ensp;<code>str "%Y/%m/%d"</code></dt>
<dd>The end time of the time window.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit to retrieve the data values in.</dd>
<dt><strong><code>p_timezone</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone for the time window and retrieved times.</dd>
<dt><strong><code>p_trim</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to trim missing values
from the beginning and end of the retrieved values.</dd>
<dt><strong><code>p_start_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window begins
on ('T') or after ('F') the start time.</dd>
<dt><strong><code>p_end_inclusive</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether the time window ends on
('T') or before ('F') the end time.</dd>
<dt><strong><code>p_previous</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the latest
value before the start of the time window.</dd>
<dt><strong><code>p_next</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the earliest
value after the end of the time window.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>str</code></dt>
<dd>The version date of the data to retrieve. If not specified or NULL,
the version date is determined by P_Max_Version.</dd>
<dt><strong><code>p_max_version</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') that specifies whether to retrieve the maximum
('T') or minimum ('F') version date if P_Version_Date is NULL.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the time series.</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return result as pandas df.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> or <code>pandas df</code></dt>
<dd>Time series data, date_time, value, quality_code.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id='Some.Fully.Qualified.Ts.Id',
                        start_time='2019/1/1', end_time='2019/9/1', return_df=True)
&gt;&gt;&gt; df.head()
                date_time       value  quality_code
    0 2018-12-31 08:00:00  574.831986             0
    1 2019-01-01 08:00:00  668.277580             0
    2 2019-01-02 08:00:00  608.812202             0
    3 2019-01-03 08:00:00  597.485463             0
    4 2019-01-04 08:00:00  560.673563             0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def retrieve_ts(
    self,
    p_cwms_ts_id,
    start_time,
    end_time,
    p_units=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=None,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    return_df=True,
):
    &#34;&#34;&#34;Retrieves time series data for a specified time series and
        time window.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier to retrieve data for.
    start_time : str &#34;%Y/%m/%d&#34;
        The start time of the time window.
    end_time : str &#34;%Y/%m/%d&#34;
        The end time of the time window.
    p_units : str
        The unit to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_trim : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
        from the beginning and end of the retrieved values.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    p_version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.


    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                            start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
    &gt;&gt;&gt; df.head()
                    date_time       value  quality_code
        0 2018-12-31 08:00:00  574.831986             0
        1 2019-01-01 08:00:00  668.277580             0
        2 2019-01-02 08:00:00  608.812202             0
        3 2019-01-03 08:00:00  597.485463             0
        4 2019-01-04 08:00:00  560.673563             0
    ```
    &#34;&#34;&#34;
    p_start_time = pd.to_datetime(start_time).to_pydatetime()
    # add one day to make it inclusive to 24:00
    p_end_time = (
        pd.to_datetime(end_time) + datetime.timedelta(days=1)
    ).to_pydatetime()

    if not version_date:
        version_date = &#34;1111/11/11&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    else:
        p_version_date = pd.to_datetime(version_date).to_pydatetime()

    cur = self.conn.cursor()
    p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
    try:

        cur.callproc(
            &#34;cwms_ts.retrieve_ts&#34;,
            [
                p_at_tsv_rc,
                p_cwms_ts_id,
                p_units,
                p_start_time,
                p_end_time,
                p_timezone,
                p_trim,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                p_version_date,
                p_max_version,
                p_office_id,
            ],
        )

    except Exception as e:
        LOGGER.error(&#34;Error in retrieving time series.&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()

    output = [r for r in p_at_tsv_rc.getvalue()]
    output_len = len(output)
    LOGGER.info(f&#34;Found {output_len} records.&#34;)

    if return_df:
        output = pd.DataFrame(
            output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
        )
        output[&#34;time_zone&#34;] = p_timezone
        output[&#34;ts_id&#34;] = p_cwms_ts_id
        if p_units:
            output[&#34;units&#34;] = p_units

    return output</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts_out"><code class="name flex">
<span>def <span class="ident">retrieve_ts_out</span></span>(<span>self, p_cwms_ts_id, start_time, end_time, p_units=None, p_timezone='UTC', p_trim='F', p_start_inclusive='T', p_end_inclusive='T', p_previous='T', p_next='F', version_date=None, p_max_version='T', p_office_id=None, return_df=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves time series data for a specified time series and
time window.</p>
<pre><code>Parameters
----------
p_cwms_ts_id : str
    The time series identifier to retrieve data for.
start_time : str "%Y/%m/%d"
    The start time of the time window.
end_time : str "%Y/%m/%d"
    The end time of the time window.
p_units : str
    The unit to retrieve the data values in.
p_timezone : str
    The time zone for the time window and retrieved times.
p_trim : str
    A flag ('T' or 'F') that specifies whether to trim missing values
    from the beginning and end of the retrieved values.
p_start_inclusive : str
    A flag ('T' or 'F') that specifies whether the time window begins
    on ('T') or after ('F') the start time.
p_end_inclusive : str
    A flag ('T' or 'F') that specifies whether the time window ends on
    ('T') or before ('F') the end time.
p_previous : str
    A flag ('T' or 'F') that specifies whether to retrieve the latest
    value before the start of the time window.
p_next : str
    A flag ('T' or 'F') that specifies whether to retrieve the earliest
    value after the end of the time window.
p_version_date : str
    The version date of the data to retrieve. If not specified or NULL,
    the version date is determined by P_Max_Version.
p_max_version : str
    A flag ('T' or 'F') that specifies whether to retrieve the maximum
    ('T') or minimum ('F') version date if P_Version_Date is NULL.
p_office_id : str
    The office that owns the time series.
return_df : bool
    Return result as pandas df.

Returns
-------
list or pandas df
    Time series data, date_time, value, quality_code.


Examples
-------
```python
&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; df = cwms.retrieve_ts_out(p_cwms_ts_id='Some.Fully.Qualified.Ts.Id',
                        start_time='2019/1/1', end_time='2019/9/1', return_df=True)
&gt;&gt;&gt; df.head()
     date_time  value  quality_code     time_zone                          ts_id                                       alias              units
</code></pre>
<p>2020-09-01 18:00:00
0.0
0
UTC
ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW
ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW
mm
2020-09-02 00:00:00
0.0
0
UTC
ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW
ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW
mm</p>
<pre><code>```
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def retrieve_ts_out(
    self,
    p_cwms_ts_id,
    start_time,
    end_time,
    p_units=None,
    p_timezone=&#34;UTC&#34;,
    p_trim=&#34;F&#34;,
    p_start_inclusive=&#34;T&#34;,
    p_end_inclusive=&#34;T&#34;,
    p_previous=&#34;T&#34;,
    p_next=&#34;F&#34;,
    version_date=None,
    p_max_version=&#34;T&#34;,
    p_office_id=None,
    return_df=True,
):
    &#34;&#34;&#34;Retrieves time series data for a specified time series and
        time window.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier to retrieve data for.
    start_time : str &#34;%Y/%m/%d&#34;
        The start time of the time window.
    end_time : str &#34;%Y/%m/%d&#34;
        The end time of the time window.
    p_units : str
        The unit to retrieve the data values in.
    p_timezone : str
        The time zone for the time window and retrieved times.
    p_trim : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to trim missing values
        from the beginning and end of the retrieved values.
    p_start_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window begins
        on (&#39;T&#39;) or after (&#39;F&#39;) the start time.
    p_end_inclusive : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether the time window ends on
        (&#39;T&#39;) or before (&#39;F&#39;) the end time.
    p_previous : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the latest
        value before the start of the time window.
    p_next : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the earliest
        value after the end of the time window.
    p_version_date : str
        The version date of the data to retrieve. If not specified or NULL,
        the version date is determined by P_Max_Version.
    p_max_version : str
        A flag (&#39;T&#39; or &#39;F&#39;) that specifies whether to retrieve the maximum
        (&#39;T&#39;) or minimum (&#39;F&#39;) version date if P_Version_Date is NULL.
    p_office_id : str
        The office that owns the time series.
    return_df : bool
        Return result as pandas df.

    Returns
    -------
    list or pandas df
        Time series data, date_time, value, quality_code.


    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; df = cwms.retrieve_ts_out(p_cwms_ts_id=&#39;Some.Fully.Qualified.Ts.Id&#39;,
                            start_time=&#39;2019/1/1&#39;, end_time=&#39;2019/9/1&#39;, return_df=True)
    &gt;&gt;&gt; df.head()
         date_time  value  quality_code     time_zone                          ts_id                                       alias              units
2020-09-01 18:00:00    0.0             0       UTC  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW    mm
2020-09-02 00:00:00    0.0             0       UTC  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW  ANAM.Precip-Inc.Total.6Hours.6Hours.RFC-RAW    mm

    ```
    &#34;&#34;&#34;
    p_start_time = pd.to_datetime(start_time).to_pydatetime()
    p_end_time = pd.to_datetime(end_time).to_pydatetime()

    if not version_date:
        version_date = &#34;1111/11/11&#34;
        p_version_date = datetime.datetime.strptime(version_date, &#34;%Y/%m/%d&#34;)
    else:
        p_version_date = pd.to_datetime(version_date).to_pydatetime()

    cur = self.conn.cursor()
    p_at_tsv_rc = self.conn.cursor().var(cx_Oracle.CURSOR)
    p_units_out = cur.var(cx_Oracle.STRING)
    p_cwms_ts_id_out = cur.var(cx_Oracle.STRING)
    try:

        cur.callproc(
            &#34;cwms_ts.retrieve_ts_out&#34;,
            [
                p_at_tsv_rc,
                p_cwms_ts_id_out,
                p_units_out,
                p_cwms_ts_id,
                p_units,
                p_start_time,
                p_end_time,
                p_timezone,
                p_trim,
                p_start_inclusive,
                p_end_inclusive,
                p_previous,
                p_next,
                p_version_date,
                p_max_version,
                p_office_id,
            ],
        )

    except Exception as e:
        LOGGER.error(&#34;Error in retrieving time series.&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()

    output = [r for r in p_at_tsv_rc.getvalue()]
    output_len = len(output)
    LOGGER.info(f&#34;Found {output_len} records.&#34;)

    if return_df:
        output = pd.DataFrame(
            output, columns=[&#34;date_time&#34;, &#34;value&#34;, &#34;quality_code&#34;]
        )
        output[&#34;time_zone&#34;] = p_timezone
        output[&#34;ts_id&#34;] = p_cwms_ts_id_out.getvalue()
        output[&#34;alias&#34;] = p_cwms_ts_id
        output[&#34;units&#34;] = p_units_out.getvalue()

    return output</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.store_by_df"><code class="name flex">
<span>def <span class="ident">store_by_df</span></span>(<span>self, df, timezone=None, p_store_rule='REPLACE ALL', p_override_prot='F', version_date=None, p_office_id=None, only_add_different=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores time series data to the database with pandas.core.dataframe as input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.core.DataFrame</code></dt>
<dd>Pandas DataFrame that requires <code>ts_id</code>, <code>date_time</code>, <code>units</code>,
and <code>value</code> columns.
If optional column <code>quality_code</code> does not exist,
all quality codes are assumed equal to 0.</dd>
<dt><strong><code>p_store_rule</code></strong> :&ensp;<code>type</code></dt>
<dd>The store rule to use.</dd>
<dt><strong><code>p_override_prot</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Description of parameter <code>p_office_id</code>.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office owning the time series. If not specified or NULL, the
session user's default office is used.</dd>
<dt><strong><code>only_add_different</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Check what is currently in database and only commit changes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd><code>True</code> for success</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; p_cwms_ts_id = 'Some.Fully.Qualified.Pathname'
&gt;&gt;&gt; p_units = 'cms'
&gt;&gt;&gt; start_time = '2019/1/1'
&gt;&gt;&gt; end_time = '2019/8/1'
&gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
&gt;&gt;&gt;                     start_time=start_time,
&gt;&gt;&gt;                     end_time=end_time,
&gt;&gt;&gt;                     p_units=p_units
&gt;&gt;&gt;                     )
&gt;&gt;&gt; df['units'] = p_units
&gt;&gt;&gt; df['ts_id'] = p_cwms_ts_id
&gt;&gt;&gt; df['value'] = df['value'] / 1.1
&gt;&gt;&gt; cwms.store_by_df(df)
    True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def store_by_df(
    self,
    df,
    timezone=None,
    p_store_rule=&#34;REPLACE ALL&#34;,
    p_override_prot=&#34;F&#34;,
    version_date=None,
    p_office_id=None,
    only_add_different=True,
):
    &#34;&#34;&#34;Stores time series data to the database with pandas.core.dataframe as input.

    Parameters
    ----------
    df : pandas.core.DataFrame
        Pandas DataFrame that requires `ts_id`, `date_time`, `units`,
        and `value` columns.  If optional column `quality_code` does not exist,
        all quality codes are assumed equal to 0.
    p_store_rule : type
        The store rule to use.
    p_override_prot : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : datetime
        Description of parameter `p_office_id`.
    p_office_id : type
        The office owning the time series. If not specified or NULL, the
        session user&#39;s default office is used.
    only_add_different : boolean
        Check what is currently in database and only commit changes

    Returns
    -------
    Boolean
        `True` for success

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Pathname&#39;
    &gt;&gt;&gt; p_units = &#39;cms&#39;
    &gt;&gt;&gt; start_time = &#39;2019/1/1&#39;
    &gt;&gt;&gt; end_time = &#39;2019/8/1&#39;
    &gt;&gt;&gt; df = cwms.retrieve_ts(p_cwms_ts_id=p_cwms_ts_id,
    &gt;&gt;&gt;                     start_time=start_time,
    &gt;&gt;&gt;                     end_time=end_time,
    &gt;&gt;&gt;                     p_units=p_units
    &gt;&gt;&gt;                     )
    &gt;&gt;&gt; df[&#39;units&#39;] = p_units
    &gt;&gt;&gt; df[&#39;ts_id&#39;] = p_cwms_ts_id
    &gt;&gt;&gt; df[&#39;value&#39;] = df[&#39;value&#39;] / 1.1
    &gt;&gt;&gt; cwms.store_by_df(df)
        True
    ```

    &#34;&#34;&#34;
    df = df.copy()
    if &#34;time_zone&#34; not in df.columns and timezone:
        df[&#34;time_zone&#34;] = timezone

    if &#34;quality_code&#34; in df.columns:
        df[&#34;quality_code&#34;] = [int(x) for x in df[&#34;quality_code&#34;].values]
    else:
        df[&#34;quality_code&#34;] = 0

    # I want to make sure everything is the right type for cx_Oracle
    df[&#34;date_time&#34;] = pd.to_datetime(df[&#34;date_time&#34;])
    df[&#34;date_time&#34;] = df[&#34;date_time&#34;].dt.tz_localize(None)
    df[&#34;value&#34;] = df[&#34;value&#34;].astype(float)

    grouped = df.groupby([&#34;ts_id&#34;, &#34;units&#34;, &#34;time_zone&#34;])
    failures = 0
    for g, v in grouped:
        p_cwms_ts_id, p_units, timezone = g

        # Add a little overlap to get current data
        min_date = (v[&#34;date_time&#34;].min() - datetime.timedelta(days=1)).strftime(
            &#34;%Y/%m/%d&#34;
        )
        max_date = (v[&#34;date_time&#34;].max() + datetime.timedelta(days=1)).strftime(
            &#34;%Y/%m/%d&#34;
        )
        if only_add_different:
            # Only want to write new data to disk
            # Get current data, merge it for comparison
            # Will throw an error if time series identifier does not exist
            new_data = v.copy()
            try:

                current_data = self.retrieve_ts(
                    p_cwms_ts_id=p_cwms_ts_id,
                    start_time=min_date,
                    end_time=max_date,
                    p_units=p_units,
                    p_timezone=timezone,
                    version_date=version_date,
                )
            except Exception as e:
                LOGGER.error(f&#34;Error retrieveing {p_cwms_ts_id} for comparison.&#34;)
                current_data = pd.DataFrame()

            if not current_data.empty:
                try:
                    merged = v.merge(
                        current_data,
                        on=[&#34;date_time&#34;, &#34;value&#34;],
                        how=&#34;outer&#34;,
                        suffixes=[&#34;&#34;, &#34;_&#34;],
                        indicator=True,
                    )
                    # The data to store after comparing to current data
                    new_data = merged[merged[&#34;_merge&#34;] == &#34;left_only&#34;]
                except:
                    LOGGER.error(
                        f&#34;Failed to merge {p_cwms_ts_id} with existing data.&#34;
                    )
            if new_data.empty:
                LOGGER.info(f&#34;No new data to load for {p_cwms_ts_id}&#34;)
                # Do not want to try and load empty data so continue
                continue
        else:
            new_data = v.copy()

        new_data_len = new_data.shape[0]
        LOGGER.info(f&#34;Loading {new_data_len} new values&#34;)

        try:
            self.store_ts(
                p_cwms_ts_id=p_cwms_ts_id,
                p_units=p_units,
                timezone=timezone,
                times=list(new_data[&#34;date_time&#34;]),
                values=list(new_data[&#34;value&#34;].astype(float)),
                qualities=list(new_data[&#34;quality_code&#34;]),
                format=None,
                p_store_rule=p_store_rule,
                p_override_prot=p_override_prot,
                version_date=version_date,
                p_office_id=p_office_id,
            )
        except Exception as e:
            LOGGER.error(f&#34;Error in store_ts for {p_cwms_ts_id}&#34;)
            LOGGER.error(e)
            failures += 1
            continue
    return failures</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.store_ts"><code class="name flex">
<span>def <span class="ident">store_ts</span></span>(<span>self, p_cwms_ts_id, p_units, times, values, timezone, qualities=None, format=None, p_store_rule='REPLACE ALL', p_override_prot='F', version_date=None, p_office_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores time series data to the database using parameter types
compatible with cx_Oracle Pyton package.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_cwms_ts_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time series identifier.</dd>
<dt><strong><code>p_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The unit of the data values.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>list</code></dt>
<dd>The times of the data values.
Can be string or type datetime</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>list</code></dt>
<dd>The data values.</dd>
<dt><strong><code>p_qualities</code></strong> :&ensp;<code>list</code></dt>
<dd>The data quality codes for the data values.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
parse all the way up to nanoseconds. See strftime documentation
for more information on choices:
<a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior</a>
store_ts will try to infer format if None.</dd>
<dt><strong><code>p_store_rule</code></strong> :&ensp;<code>type</code></dt>
<dd>The store rule to use.</dd>
<dt><strong><code>p_override_prot</code></strong> :&ensp;<code>str</code></dt>
<dd>A flag ('T' or 'F') specifying whether to override the protection
flag on any existing data value.</dd>
<dt><strong><code>p_version_date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>Description of parameter <code>p_office_id</code>.</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>type</code></dt>
<dd>The office owning the time series. If not specified or NULL, the
session user's default office is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Boolean</code></dt>
<dd>True for success.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; p_cwms_ts_id = 'Some.Fully.Qualified.Cwms.Ts.ID'
&gt;&gt;&gt; p_units = &quot;cms&quot;
&gt;&gt;&gt; values = [1,2,3]
&gt;&gt;&gt; p_qualities = [0,0,0]
&gt;&gt;&gt; times = ['2019/1/1','2019/1/2','2019/1/3']
&gt;&gt;&gt; times = [datetime.datetime.strptime(x, &quot;%Y/%m/%d&quot;) for x in times]
&gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
    True 
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def store_ts(
    self,
    p_cwms_ts_id,
    p_units,
    times,
    values,
    timezone,
    qualities=None,
    format=None,
    p_store_rule=&#34;REPLACE ALL&#34;,
    p_override_prot=&#34;F&#34;,
    version_date=None,
    p_office_id=None,
):
    &#34;&#34;&#34;Stores time series data to the database using parameter types
        compatible with cx_Oracle Pyton package.

    Parameters
    ----------
    p_cwms_ts_id : str
        The time series identifier.
    p_units : str
        The unit of the data values.
    times : list
        The times of the data values.  Can be string or type datetime
    values : list
        The data values.
    p_qualities : list
        The data quality codes for the data values.
    format : str
        strftime to parse time, eg “%d/%m/%Y”, note that “%f” will
        parse all the way up to nanoseconds. See strftime documentation
        for more information on choices:
            https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
        store_ts will try to infer format if None.
    p_store_rule : type
        The store rule to use.
    p_override_prot : str
        A flag (&#39;T&#39; or &#39;F&#39;) specifying whether to override the protection
        flag on any existing data value.
    p_version_date : datetime
        Description of parameter `p_office_id`.
    p_office_id : type
        The office owning the time series. If not specified or NULL, the
        session user&#39;s default office is used.

    Returns
    -------
    Boolean
        True for success.

    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; import datetime
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; p_cwms_ts_id = &#39;Some.Fully.Qualified.Cwms.Ts.ID&#39;
    &gt;&gt;&gt; p_units = &#34;cms&#34;
    &gt;&gt;&gt; values = [1,2,3]
    &gt;&gt;&gt; p_qualities = [0,0,0]
    &gt;&gt;&gt; times = [&#39;2019/1/1&#39;,&#39;2019/1/2&#39;,&#39;2019/1/3&#39;]
    &gt;&gt;&gt; times = [datetime.datetime.strptime(x, &#34;%Y/%m/%d&#34;) for x in times]
    &gt;&gt;&gt; cwms.store_ts(p_cwms_ts_id, p_units, times, values, p_qualities)
        True 
    ```
    &#34;&#34;&#34;

    cur = self.conn.cursor()
    # values.insert(0, values[0])
    p_values = cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values)

    ts = pd.to_datetime(
        times, infer_datetime_format=True, format=format
    ).tz_localize(timezone)
    ts = [t.tz_convert(&#34;UTC&#34;) for t in ts]

    # Get the UTC times of the data values in Java milliseconds
    # this is what actually goes into Store_Ts
    zero = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
    p_times = [((time - zero).total_seconds() * 1000) for time in ts]
    # p_times.insert(0, p_times[0])

    if not version_date:
        p_version_date = datetime.datetime(1111, 11, 11)
    else:
        p_version_date = version_date
    if not qualities:
        p_qualities = [0 for x in p_times]
    else:
        p_qualities = qualities

    try:
        data_len = len(values)
        LOGGER.info(f&#34;Loading {data_len} values for {p_cwms_ts_id}&#34;)

        test = cur.callproc(
            &#34;cwms_ts.store_ts&#34;,
            [
                p_cwms_ts_id,
                p_units,
                p_times,
                p_values,
                p_qualities,
                p_store_rule,
                p_override_prot,
                p_version_date,
                p_office_id,
            ],
        )

    except Exception as e:
        LOGGER.error(&#34;Error in store_ts.&#34;)
        cur.close()
        raise ValueError(e.__str__())
    cur.close()
    return True</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_ts.CwmsTsMixin.update_ts_id"><code class="name flex">
<span>def <span class="ident">update_ts_id</span></span>(<span>self, p_cwms_ts_id, p_interval_utc_offset=None, p_snap_forward_minutes=None, p_snap_backward_minutes=None, p_local_reg_time_zone_id=None, p_ts_active_flag=None, p_db_officeid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def update_ts_id(
    self,
    p_cwms_ts_id,
    p_interval_utc_offset=None,
    p_snap_forward_minutes=None,
    p_snap_backward_minutes=None,
    p_local_reg_time_zone_id=None,
    p_ts_active_flag=None,
    p_db_officeid=None,
):

    cur = self.conn.cursor()
    try:

        cur.callproc(
            &#34;cwms_ts.update_ts_id&#34;,
            [
                p_cwms_ts_id,
                p_interval_utc_offset,
                p_snap_forward_minutes,
                p_snap_backward_minutes,
                p_local_reg_time_zone_id,
                p_ts_active_flag,
                p_db_officeid,
            ],
        )
    except Exception as e:
        LOGGER.error(&#34;Error in update_ts_id.&#34;)
        cur.close()
        raise ValueError(e)
    cur.close()
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cwmspy" href="index.html">cwmspy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cwmspy.cwms_ts.CwmsTsMixin" href="#cwmspy.cwms_ts.CwmsTsMixin">CwmsTsMixin</a></code></h4>
<ul class="">
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.compare_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.compare_ts">compare_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.create_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.create_ts">create_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_by_df" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_by_df">delete_by_df</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_ts">delete_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.delete_ts_values" href="#cwmspy.cwms_ts.CwmsTsMixin.delete_ts_values">delete_ts_values</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_extents" href="#cwmspy.cwms_ts.CwmsTsMixin.get_extents">get_extents</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_por" href="#cwmspy.cwms_ts.CwmsTsMixin.get_por">get_por</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_times_for_time_window" href="#cwmspy.cwms_ts.CwmsTsMixin.get_times_for_time_window">get_times_for_time_window</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_code" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_code">get_ts_code</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_max_date">get_ts_max_date</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date" href="#cwmspy.cwms_ts.CwmsTsMixin.get_ts_min_date">get_ts_min_date</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.rename_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.rename_ts">rename_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.retrieve_time_series" href="#cwmspy.cwms_ts.CwmsTsMixin.retrieve_time_series">retrieve_time_series</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts">retrieve_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts_out" href="#cwmspy.cwms_ts.CwmsTsMixin.retrieve_ts_out">retrieve_ts_out</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.store_by_df" href="#cwmspy.cwms_ts.CwmsTsMixin.store_by_df">store_by_df</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.store_ts" href="#cwmspy.cwms_ts.CwmsTsMixin.store_ts">store_ts</a></code></li>
<li><code><a title="cwmspy.cwms_ts.CwmsTsMixin.update_ts_id" href="#cwmspy.cwms_ts.CwmsTsMixin.update_ts_id">update_ts_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>