<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>cwmspy.cwms_level API documentation</title>
<meta name="description" content="Facilities for working with location levels." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cwmspy.cwms_level</code></h1>
</header>
<section id="section-intro">
<p>Facilities for working with location levels.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Facilities for working with location levels.
&#34;&#34;&#34;
import datetime
from datetime import timedelta
import json
from json import JSONDecodeError

import cx_Oracle
import pandas as pd
import logging


from .utils import log_decorator


LOGGER = logging.getLogger(__name__)
LD = log_decorator(LOGGER)


class CwmsLevelMixin:
    @LD
    def retrieve_location_level_values(
        self,
        p_location_level_id,
        p_start_time,
        p_end_time,
        p_level_units,
        p_timezone_id=&#34;GMT&#34;,
        p_office_id=&#34;NWDP&#34;,
        df=True,
    ):
        &#34;&#34;&#34;
        
        Retrieves a time series of location level values for a specified location level and a time window.

        Parameters
        ----------
        p_location_level_id : str
            The location level identifier. Format is location.parameter.parameter_type.duration.specified_level
        p_start_time : str 
            The start of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_end_time : str
            The end of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_level_units : str
            The value unit to retrieve the level values in
        p_timezone_id : str
            The time zone of the time window. Retrieved dates are also in this time zone (the default is &#34;GMT&#34;).
        p_office_id : str
            The office that owns the location level. If not specified or NULL, the session user&#39;s default office is used` (the default is &#34;NWDP&#34;).
        df : boolean
            Return a pandas.Core.DataFrame (the default is True).

        Returns
        -------
        type: either list or pandas.Core.DataFrame
        The location level values. The time series contains values at the spcified start and end times of the time window and may contain values at intermediate times
            * If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero
            * If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero
            * If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero
        The quality code of each returned value will be one of the following
            * 0: The value for all times between the previous value time and this one is the same as the previous value
            * 1: The value for all times between the previous value time and this one is interpolated between the previous value and this one
                
        
        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_location_level_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_level_units = &#39;cms&#39;
        &gt;&gt;&gt; p_start_time = &#39;01/01/2000&#39;
        &gt;&gt;&gt; p_end_time = &#39;05/01/2000&#39;
        &gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_location_level_id=p_location_level_id,
        &gt;&gt;&gt;                     p_start_time=p_start_time,
        &gt;&gt;&gt;                     p_end_time=p_end_time,
        &gt;&gt;&gt;                     p_level_units=p_level_units
        &gt;&gt;&gt;                     )
        ```

        &#34;&#34;&#34;
        p_start_time = pd.to_datetime(p_start_time).to_pydatetime().strftime(&#34;%Y-%m-%d&#34;)
        p_end_time = pd.to_datetime(p_end_time).to_pydatetime().strftime(&#34;%Y-%m-%d&#34;)

        try:
            cur = self.conn.cursor()

            bind_vars = {
                &#34;p_location_level_id&#34;: p_location_level_id,
                &#34;p_level_units&#34;: p_level_units,
                &#34;p_start_time&#34;: p_start_time,
                &#34;p_end_time&#34;: p_end_time,
                &#34;p_timezone_id&#34;: p_timezone_id,
                &#34;p_office_id&#34;: p_office_id,
            }

            LOGGER.info(&#34;Start retrieve_location_level_values.&#34;)
            cur.execute(
                &#34;&#34;&#34;
                select * from table( cwms_level.retrieve_location_level_values(
                p_location_level_id =&gt;:p_location_level_id,
                p_level_units       =&gt;:p_level_units,
                p_start_time        =&gt;to_date( :p_start_time, &#39;yyyy-mm-dd&#39; ),
                p_end_time          =&gt;to_date( :p_end_time, &#39;yyyy-mm-dd&#39; ),
                p_timezone_id       =&gt;:p_timezone_id,
                p_office_id         =&gt;:p_office_id ) )&#34;&#34;&#34;,
                bind_vars,
            )
            records = cur.fetchall()
            cur.close()
        except Exception as e:
            LOGGER.error(&#34;Error in retrieve_location_level_values.&#34;)
            cur.close()
            # print bind_vars
            raise ValueError(e.__str__())
        result = []
        # The following code deals with the hacky location level API call that HEC
        # Implemented. The quality flag is an interpolation flag, meaning 0 is not
        # to be interopolated.
        lastVal = None
        for row in records:
            if row[2] == 0 and lastVal != None:
                result.append([row[0] - timedelta(minutes=1), lastVal, row[2]])
            result.append(row)
            lastVal = row[1]
        records = str(len(result))
        LOGGER.info(f&#34;Found {records} records.&#34;)
        if df:
            result = pd.DataFrame(result)
            result.columns = [&#34;date&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            result[&#34;location_level_id&#34;] = p_location_level_id
            if p_level_units:
                result[&#34;units&#34;] = p_level_units
        LOGGER.info(&#34;End retrieve_location_level_values.&#34;)
        return result

    @LD
    def retrieve_location_levels(
        self,
        p_names=None,
        p_format=None,
        p_units=None,
        p_datums=None,
        p_start=None,
        p_end=None,
        p_timezone=&#34;UTC&#34;,
        p_office_id=None,
        as_json=False,
    ):

        p_names = &#34;|&#34;.join(p_names)
        if p_units:
            p_units = &#34;|&#34;.join(p_units)

        cur = self.conn.cursor()

        p_results = cur.var(cx_Oracle.CLOB)
        p_date_time = cur.var(cx_Oracle.DATETIME)
        p_query_time = cur.var(int)
        p_format_time = cur.var(int)
        p_count = cur.var(int)

        if p_start:
            p_start = pd.to_datetime(p_start).strftime(&#34;%Y-%m-%d&#34;)
        if p_end:
            # add one day to make it inclusive to 24:00
            p_end = (pd.to_datetime(p_end) + datetime.timedelta(days=1)).strftime(
                &#34;%Y-%m-%d&#34;
            )

        try:

            clob = cur.callproc(
                &#34;cwms_level.retrieve_location_levels&#34;,
                [
                    p_results,
                    p_date_time,
                    p_query_time,
                    p_format_time,
                    p_count,
                    p_names,
                    p_format,
                    p_units,
                    p_datums,
                    p_start,
                    p_end,
                    p_timezone,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series&#34;)
            cur.close()
            raise ValueError(e)
        cur.close()
        try:
            result = json.loads(clob[0].read())
            if as_json:
                return result
        except JSONDecodeError as e:
            LOGGER.info(&#34;No data for the requested pathnames and dates.&#34;)
            raise e

        try:
            levels = result[&#34;location-levels&#34;][&#34;location-levels&#34;]
        except KeyError:
            LOGGER.warning(&#34;No data found&#34;)
            return pd.DataFrame()

        df_list = []
        for data in levels:
            location_level_id = data[&#34;name&#34;]
            parameter = data[&#34;values&#34;][&#34;parameter&#34;]
            segments = data[&#34;values&#34;][&#34;segments&#34;]
            df_l = []
            for segment in segments:
                interpolate = eval(segment[&#34;interpolate&#34;].capitalize())

                values = segment[&#34;values&#34;]

                df = pd.DataFrame(values, columns=[&#34;date_time&#34;, &#34;value&#34;])
                df[&#34;parameter&#34;] = parameter
                df[&#34;interpolate&#34;] = interpolate
                df.insert(0, &#34;location_level_id&#34;, location_level_id)
                df_l.append(df)
            df = pd.concat(df_l)
            df_list.append(df)

        df = pd.concat(df_list)

        return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cwmspy.cwms_level.CwmsLevelMixin"><code class="flex name class">
<span>class <span class="ident">CwmsLevelMixin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CwmsLevelMixin:
    @LD
    def retrieve_location_level_values(
        self,
        p_location_level_id,
        p_start_time,
        p_end_time,
        p_level_units,
        p_timezone_id=&#34;GMT&#34;,
        p_office_id=&#34;NWDP&#34;,
        df=True,
    ):
        &#34;&#34;&#34;
        
        Retrieves a time series of location level values for a specified location level and a time window.

        Parameters
        ----------
        p_location_level_id : str
            The location level identifier. Format is location.parameter.parameter_type.duration.specified_level
        p_start_time : str 
            The start of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_end_time : str
            The end of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
        p_level_units : str
            The value unit to retrieve the level values in
        p_timezone_id : str
            The time zone of the time window. Retrieved dates are also in this time zone (the default is &#34;GMT&#34;).
        p_office_id : str
            The office that owns the location level. If not specified or NULL, the session user&#39;s default office is used` (the default is &#34;NWDP&#34;).
        df : boolean
            Return a pandas.Core.DataFrame (the default is True).

        Returns
        -------
        type: either list or pandas.Core.DataFrame
        The location level values. The time series contains values at the spcified start and end times of the time window and may contain values at intermediate times
            * If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero
            * If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero
            * If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero
        The quality code of each returned value will be one of the following
            * 0: The value for all times between the previous value time and this one is the same as the previous value
            * 1: The value for all times between the previous value time and this one is interpolated between the previous value and this one
                
        
        Examples
        -------
        ```python
        &gt;&gt;&gt; from cwmspy import CWMS
        &gt;&gt;&gt; cwms = CWMS()
        &gt;&gt;&gt; cwms.connect()
            True
        &gt;&gt;&gt; p_location_level_id = &#39;Some.Fully.Qualified.Pathname&#39;
        &gt;&gt;&gt; p_level_units = &#39;cms&#39;
        &gt;&gt;&gt; p_start_time = &#39;01/01/2000&#39;
        &gt;&gt;&gt; p_end_time = &#39;05/01/2000&#39;
        &gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_location_level_id=p_location_level_id,
        &gt;&gt;&gt;                     p_start_time=p_start_time,
        &gt;&gt;&gt;                     p_end_time=p_end_time,
        &gt;&gt;&gt;                     p_level_units=p_level_units
        &gt;&gt;&gt;                     )
        ```

        &#34;&#34;&#34;
        p_start_time = pd.to_datetime(p_start_time).to_pydatetime().strftime(&#34;%Y-%m-%d&#34;)
        p_end_time = pd.to_datetime(p_end_time).to_pydatetime().strftime(&#34;%Y-%m-%d&#34;)

        try:
            cur = self.conn.cursor()

            bind_vars = {
                &#34;p_location_level_id&#34;: p_location_level_id,
                &#34;p_level_units&#34;: p_level_units,
                &#34;p_start_time&#34;: p_start_time,
                &#34;p_end_time&#34;: p_end_time,
                &#34;p_timezone_id&#34;: p_timezone_id,
                &#34;p_office_id&#34;: p_office_id,
            }

            LOGGER.info(&#34;Start retrieve_location_level_values.&#34;)
            cur.execute(
                &#34;&#34;&#34;
                select * from table( cwms_level.retrieve_location_level_values(
                p_location_level_id =&gt;:p_location_level_id,
                p_level_units       =&gt;:p_level_units,
                p_start_time        =&gt;to_date( :p_start_time, &#39;yyyy-mm-dd&#39; ),
                p_end_time          =&gt;to_date( :p_end_time, &#39;yyyy-mm-dd&#39; ),
                p_timezone_id       =&gt;:p_timezone_id,
                p_office_id         =&gt;:p_office_id ) )&#34;&#34;&#34;,
                bind_vars,
            )
            records = cur.fetchall()
            cur.close()
        except Exception as e:
            LOGGER.error(&#34;Error in retrieve_location_level_values.&#34;)
            cur.close()
            # print bind_vars
            raise ValueError(e.__str__())
        result = []
        # The following code deals with the hacky location level API call that HEC
        # Implemented. The quality flag is an interpolation flag, meaning 0 is not
        # to be interopolated.
        lastVal = None
        for row in records:
            if row[2] == 0 and lastVal != None:
                result.append([row[0] - timedelta(minutes=1), lastVal, row[2]])
            result.append(row)
            lastVal = row[1]
        records = str(len(result))
        LOGGER.info(f&#34;Found {records} records.&#34;)
        if df:
            result = pd.DataFrame(result)
            result.columns = [&#34;date&#34;, &#34;value&#34;, &#34;quality_code&#34;]
            result[&#34;location_level_id&#34;] = p_location_level_id
            if p_level_units:
                result[&#34;units&#34;] = p_level_units
        LOGGER.info(&#34;End retrieve_location_level_values.&#34;)
        return result

    @LD
    def retrieve_location_levels(
        self,
        p_names=None,
        p_format=None,
        p_units=None,
        p_datums=None,
        p_start=None,
        p_end=None,
        p_timezone=&#34;UTC&#34;,
        p_office_id=None,
        as_json=False,
    ):

        p_names = &#34;|&#34;.join(p_names)
        if p_units:
            p_units = &#34;|&#34;.join(p_units)

        cur = self.conn.cursor()

        p_results = cur.var(cx_Oracle.CLOB)
        p_date_time = cur.var(cx_Oracle.DATETIME)
        p_query_time = cur.var(int)
        p_format_time = cur.var(int)
        p_count = cur.var(int)

        if p_start:
            p_start = pd.to_datetime(p_start).strftime(&#34;%Y-%m-%d&#34;)
        if p_end:
            # add one day to make it inclusive to 24:00
            p_end = (pd.to_datetime(p_end) + datetime.timedelta(days=1)).strftime(
                &#34;%Y-%m-%d&#34;
            )

        try:

            clob = cur.callproc(
                &#34;cwms_level.retrieve_location_levels&#34;,
                [
                    p_results,
                    p_date_time,
                    p_query_time,
                    p_format_time,
                    p_count,
                    p_names,
                    p_format,
                    p_units,
                    p_datums,
                    p_start,
                    p_end,
                    p_timezone,
                    p_office_id,
                ],
            )

        except Exception as e:
            LOGGER.error(&#34;Error in retrieving time series&#34;)
            cur.close()
            raise ValueError(e)
        cur.close()
        try:
            result = json.loads(clob[0].read())
            if as_json:
                return result
        except JSONDecodeError as e:
            LOGGER.info(&#34;No data for the requested pathnames and dates.&#34;)
            raise e

        try:
            levels = result[&#34;location-levels&#34;][&#34;location-levels&#34;]
        except KeyError:
            LOGGER.warning(&#34;No data found&#34;)
            return pd.DataFrame()

        df_list = []
        for data in levels:
            location_level_id = data[&#34;name&#34;]
            parameter = data[&#34;values&#34;][&#34;parameter&#34;]
            segments = data[&#34;values&#34;][&#34;segments&#34;]
            df_l = []
            for segment in segments:
                interpolate = eval(segment[&#34;interpolate&#34;].capitalize())

                values = segment[&#34;values&#34;]

                df = pd.DataFrame(values, columns=[&#34;date_time&#34;, &#34;value&#34;])
                df[&#34;parameter&#34;] = parameter
                df[&#34;interpolate&#34;] = interpolate
                df.insert(0, &#34;location_level_id&#34;, location_level_id)
                df_l.append(df)
            df = pd.concat(df_l)
            df_list.append(df)

        df = pd.concat(df_list)

        return df</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cwmspy.core.CWMS" href="core.html#cwmspy.core.CWMS">CWMS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_level_values"><code class="name flex">
<span>def <span class="ident">retrieve_location_level_values</span></span>(<span>self, p_location_level_id, p_start_time, p_end_time, p_level_units, p_timezone_id='GMT', p_office_id='NWDP', df=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a time series of location level values for a specified location level and a time window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_location_level_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The location level identifier. Format is location.parameter.parameter_type.duration.specified_level</dd>
<dt><strong><code>p_start_time</code></strong> :&ensp;<code>str </code></dt>
<dd>The start of the time window.
Format : 'dd-mm-yyyy hh24mi'.</dd>
<dt><strong><code>p_end_time</code></strong> :&ensp;<code>str</code></dt>
<dd>The end of the time window.
Format : 'dd-mm-yyyy hh24mi'.</dd>
<dt><strong><code>p_level_units</code></strong> :&ensp;<code>str</code></dt>
<dd>The value unit to retrieve the level values in</dd>
<dt><strong><code>p_timezone_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The time zone of the time window. Retrieved dates are also in this time zone (the default is "GMT").</dd>
<dt><strong><code>p_office_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The office that owns the location level. If not specified or NULL, the session user's default office is used` (the default is "NWDP").</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Return a pandas.Core.DataFrame (the default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>either list</code> or <code>pandas.Core.DataFrame</code></dt>
<dd>&nbsp;</dd>
<dt><code>The location level values. The time series contains values at the spcified start and end times</code> of <code>the time window and may contain values at intermediate times</code></dt>
<dd>
<ul>
<li>If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero</li>
<li>If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero</li>
<li>If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero</li>
</ul>
</dd>
<dt><code>The quality code</code> of <code>each returned value will be one</code> of <code>the following</code></dt>
<dd>
<ul>
<li>0: The value for all times between the previous value time and this one is the same as the previous value</li>
<li>1: The value for all times between the previous value time and this one is interpolated between the previous value and this one</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; from cwmspy import CWMS
&gt;&gt;&gt; cwms = CWMS()
&gt;&gt;&gt; cwms.connect()
    True
&gt;&gt;&gt; p_location_level_id = 'Some.Fully.Qualified.Pathname'
&gt;&gt;&gt; p_level_units = 'cms'
&gt;&gt;&gt; p_start_time = '01/01/2000'
&gt;&gt;&gt; p_end_time = '05/01/2000'
&gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_location_level_id=p_location_level_id,
&gt;&gt;&gt;                     p_start_time=p_start_time,
&gt;&gt;&gt;                     p_end_time=p_end_time,
&gt;&gt;&gt;                     p_level_units=p_level_units
&gt;&gt;&gt;                     )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def retrieve_location_level_values(
    self,
    p_location_level_id,
    p_start_time,
    p_end_time,
    p_level_units,
    p_timezone_id=&#34;GMT&#34;,
    p_office_id=&#34;NWDP&#34;,
    df=True,
):
    &#34;&#34;&#34;
    
    Retrieves a time series of location level values for a specified location level and a time window.

    Parameters
    ----------
    p_location_level_id : str
        The location level identifier. Format is location.parameter.parameter_type.duration.specified_level
    p_start_time : str 
        The start of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
    p_end_time : str
        The end of the time window.  Format : &#39;dd-mm-yyyy hh24mi&#39;.
    p_level_units : str
        The value unit to retrieve the level values in
    p_timezone_id : str
        The time zone of the time window. Retrieved dates are also in this time zone (the default is &#34;GMT&#34;).
    p_office_id : str
        The office that owns the location level. If not specified or NULL, the session user&#39;s default office is used` (the default is &#34;NWDP&#34;).
    df : boolean
        Return a pandas.Core.DataFrame (the default is True).

    Returns
    -------
    type: either list or pandas.Core.DataFrame
    The location level values. The time series contains values at the spcified start and end times of the time window and may contain values at intermediate times
        * If the level is constant, the time series will be of length 2 and the quality_codes of both elements will be zero
        * If the level varies in a recurring pattern, the time series will include values at any pattern breakpoints in the time window. The quality_codes of all elements will be zero
        * If the level varies irregularly, the time series will include values of at any times of the representing time series that are in the time window. The quality codes of times within the time window will be the quality codes of the representing time series. The quality codes of the elements at the beginning and end of the time window may be zero
    The quality code of each returned value will be one of the following
        * 0: The value for all times between the previous value time and this one is the same as the previous value
        * 1: The value for all times between the previous value time and this one is interpolated between the previous value and this one
            
    
    Examples
    -------
    ```python
    &gt;&gt;&gt; from cwmspy import CWMS
    &gt;&gt;&gt; cwms = CWMS()
    &gt;&gt;&gt; cwms.connect()
        True
    &gt;&gt;&gt; p_location_level_id = &#39;Some.Fully.Qualified.Pathname&#39;
    &gt;&gt;&gt; p_level_units = &#39;cms&#39;
    &gt;&gt;&gt; p_start_time = &#39;01/01/2000&#39;
    &gt;&gt;&gt; p_end_time = &#39;05/01/2000&#39;
    &gt;&gt;&gt; df = cwms.retrieve_location_level_values(p_location_level_id=p_location_level_id,
    &gt;&gt;&gt;                     p_start_time=p_start_time,
    &gt;&gt;&gt;                     p_end_time=p_end_time,
    &gt;&gt;&gt;                     p_level_units=p_level_units
    &gt;&gt;&gt;                     )
    ```

    &#34;&#34;&#34;
    p_start_time = pd.to_datetime(p_start_time).to_pydatetime().strftime(&#34;%Y-%m-%d&#34;)
    p_end_time = pd.to_datetime(p_end_time).to_pydatetime().strftime(&#34;%Y-%m-%d&#34;)

    try:
        cur = self.conn.cursor()

        bind_vars = {
            &#34;p_location_level_id&#34;: p_location_level_id,
            &#34;p_level_units&#34;: p_level_units,
            &#34;p_start_time&#34;: p_start_time,
            &#34;p_end_time&#34;: p_end_time,
            &#34;p_timezone_id&#34;: p_timezone_id,
            &#34;p_office_id&#34;: p_office_id,
        }

        LOGGER.info(&#34;Start retrieve_location_level_values.&#34;)
        cur.execute(
            &#34;&#34;&#34;
            select * from table( cwms_level.retrieve_location_level_values(
            p_location_level_id =&gt;:p_location_level_id,
            p_level_units       =&gt;:p_level_units,
            p_start_time        =&gt;to_date( :p_start_time, &#39;yyyy-mm-dd&#39; ),
            p_end_time          =&gt;to_date( :p_end_time, &#39;yyyy-mm-dd&#39; ),
            p_timezone_id       =&gt;:p_timezone_id,
            p_office_id         =&gt;:p_office_id ) )&#34;&#34;&#34;,
            bind_vars,
        )
        records = cur.fetchall()
        cur.close()
    except Exception as e:
        LOGGER.error(&#34;Error in retrieve_location_level_values.&#34;)
        cur.close()
        # print bind_vars
        raise ValueError(e.__str__())
    result = []
    # The following code deals with the hacky location level API call that HEC
    # Implemented. The quality flag is an interpolation flag, meaning 0 is not
    # to be interopolated.
    lastVal = None
    for row in records:
        if row[2] == 0 and lastVal != None:
            result.append([row[0] - timedelta(minutes=1), lastVal, row[2]])
        result.append(row)
        lastVal = row[1]
    records = str(len(result))
    LOGGER.info(f&#34;Found {records} records.&#34;)
    if df:
        result = pd.DataFrame(result)
        result.columns = [&#34;date&#34;, &#34;value&#34;, &#34;quality_code&#34;]
        result[&#34;location_level_id&#34;] = p_location_level_id
        if p_level_units:
            result[&#34;units&#34;] = p_level_units
    LOGGER.info(&#34;End retrieve_location_level_values.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_levels"><code class="name flex">
<span>def <span class="ident">retrieve_location_levels</span></span>(<span>self, p_names=None, p_format=None, p_units=None, p_datums=None, p_start=None, p_end=None, p_timezone='UTC', p_office_id=None, as_json=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@LD
def retrieve_location_levels(
    self,
    p_names=None,
    p_format=None,
    p_units=None,
    p_datums=None,
    p_start=None,
    p_end=None,
    p_timezone=&#34;UTC&#34;,
    p_office_id=None,
    as_json=False,
):

    p_names = &#34;|&#34;.join(p_names)
    if p_units:
        p_units = &#34;|&#34;.join(p_units)

    cur = self.conn.cursor()

    p_results = cur.var(cx_Oracle.CLOB)
    p_date_time = cur.var(cx_Oracle.DATETIME)
    p_query_time = cur.var(int)
    p_format_time = cur.var(int)
    p_count = cur.var(int)

    if p_start:
        p_start = pd.to_datetime(p_start).strftime(&#34;%Y-%m-%d&#34;)
    if p_end:
        # add one day to make it inclusive to 24:00
        p_end = (pd.to_datetime(p_end) + datetime.timedelta(days=1)).strftime(
            &#34;%Y-%m-%d&#34;
        )

    try:

        clob = cur.callproc(
            &#34;cwms_level.retrieve_location_levels&#34;,
            [
                p_results,
                p_date_time,
                p_query_time,
                p_format_time,
                p_count,
                p_names,
                p_format,
                p_units,
                p_datums,
                p_start,
                p_end,
                p_timezone,
                p_office_id,
            ],
        )

    except Exception as e:
        LOGGER.error(&#34;Error in retrieving time series&#34;)
        cur.close()
        raise ValueError(e)
    cur.close()
    try:
        result = json.loads(clob[0].read())
        if as_json:
            return result
    except JSONDecodeError as e:
        LOGGER.info(&#34;No data for the requested pathnames and dates.&#34;)
        raise e

    try:
        levels = result[&#34;location-levels&#34;][&#34;location-levels&#34;]
    except KeyError:
        LOGGER.warning(&#34;No data found&#34;)
        return pd.DataFrame()

    df_list = []
    for data in levels:
        location_level_id = data[&#34;name&#34;]
        parameter = data[&#34;values&#34;][&#34;parameter&#34;]
        segments = data[&#34;values&#34;][&#34;segments&#34;]
        df_l = []
        for segment in segments:
            interpolate = eval(segment[&#34;interpolate&#34;].capitalize())

            values = segment[&#34;values&#34;]

            df = pd.DataFrame(values, columns=[&#34;date_time&#34;, &#34;value&#34;])
            df[&#34;parameter&#34;] = parameter
            df[&#34;interpolate&#34;] = interpolate
            df.insert(0, &#34;location_level_id&#34;, location_level_id)
            df_l.append(df)
        df = pd.concat(df_l)
        df_list.append(df)

    df = pd.concat(df_list)

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cwmspy" href="index.html">cwmspy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cwmspy.cwms_level.CwmsLevelMixin" href="#cwmspy.cwms_level.CwmsLevelMixin">CwmsLevelMixin</a></code></h4>
<ul class="">
<li><code><a title="cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_level_values" href="#cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_level_values">retrieve_location_level_values</a></code></li>
<li><code><a title="cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_levels" href="#cwmspy.cwms_level.CwmsLevelMixin.retrieve_location_levels">retrieve_location_levels</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>